// Admin Service
// Comprehensive administration and platform management import { supabase } from '@/integrations/supabase/client';
import { Tables, TablesInsert, TablesUpdate } from '@/integrations/supabase/types';
import { userManagementService } from './userManagementService';
import { analyticsService } from './analyticsService';
import { auditService } from './auditService';
import { notificationService } from './notifications';
import { collaborationService } from './collaborations';
import { paymentsService } from './payments';
import { authService } from './authService'; export interface AdminDashboardData { platform_metrics: { total_users: number; active_users: number; total_collaborations: number; revenue_today: number; revenue_month: number; growth_rate: number; }; recent_activities: Array<{ id: string; type: string; description: string; user: string; timestamp: string; severity: 'low' | 'medium' | 'high' | 'critical'; }>; system_health: { status: 'healthy' | 'warning' | 'critical'; uptime: number; response_time: number; error_rate: number; active_connections: number; }; alerts: Array<{ id: string; type: 'security' | 'performance' | 'business' | 'system'; message: string; severity: 'low' | 'medium' | 'high' | 'critical'; created_at: string; resolved: boolean; }>;
} export interface PlatformConfiguration { id: string; key: string; value: any; description: string; category: 'general' | 'payments' | 'notifications' | 'security' | 'features'; data_type: 'string' | 'number' | 'boolean' | 'json'; is_public: boolean; created_at: string; updated_at: string;
} export interface SystemReport { report_type: 'users' | 'revenue' | 'collaborations' | 'performance' | 'security'; period: 'daily' | 'weekly' | 'monthly' | 'yearly'; data: any; generated_at: string; generated_by: string;
} export interface ModerationAction { id: string; admin_id: string; target_type: 'user' | 'collaboration' | 'content' | 'payment'; target_id: string; action: 'approve' | 'reject' | 'suspend' | 'delete' | 'flag' | 'warn'; reason: string; details?: string; expires_at?: string; created_at: string;
} class AdminService { // Get admin dashboard data async getDashboardData(): Promise<AdminDashboardData> { try { // Check admin permissions const hasPermission = await authService.hasRole('admin'); if (!hasPermission) { throw new Error('Acceso denegado. Se requieren permisos de administrador.'); } // Get platform metrics const platformMetrics = await analyticsService.getPlatformMetrics(); // Get recent activities from audit logs const recentAuditEvents = await auditService.getAuditEvents({}, 20); const recentActivities = recentAuditEvents.map(event => ({ id: event.id || '', type: event.event_type, description: event.action, user: event.user_email || 'Sistema', timestamp: event.created_at || '', severity: event.severity })); // Get system health metrics const performanceMetrics = await analyticsService.getPerformanceMetrics(); const systemHealth = { status: this.getSystemHealthStatus(performanceMetrics), uptime: performanceMetrics.uptime_percentage, response_time: performanceMetrics.avg_response_time, error_rate: performanceMetrics.error_rate, active_connections: 150 // Mock data }; // Get active alerts const alerts = await this.getSystemAlerts(); return { platform_metrics: { total_users: platformMetrics.total_users, active_users: platformMetrics.active_users_30d, total_collaborations: platformMetrics.total_collaborations, revenue_today: platformMetrics.revenue_30d * 0.1, // Mock daily revenue revenue_month: platformMetrics.revenue_30d, growth_rate: platformMetrics.user_growth_rate }, recent_activities: recentActivities, system_health: systemHealth, alerts }; } catch (error) { console.error('Failed to get dashboard data:', error); return this.getMockDashboardData(); } } // Get platform configuration async getPlatformConfiguration(): Promise<PlatformConfiguration[]> { try { const { data, error } = await supabase .from('platform_config') .select('*') .order('category', { ascending: true }); if (error) { throw error; } return data || []; } catch (error) { console.error('Failed to get platform configuration:', error); return this.getMockConfiguration(); } } // Update platform configuration async updateConfiguration( key: string, value: any, adminId: string ): Promise<PlatformConfiguration> { try { const { data, error } = await supabase .from('platform_config') .update({ value, updated_at: new Date().toISOString() }) .eq('key', key) .select() .single(); if (error) { throw error; } // Log configuration change await auditService.logAdminAction( adminId, (await authService.getCurrentUser())?.user?.email || 'admin', 'Updated platform configuration', undefined, { config_key: key, new_value: value } ); return data; } catch (error) { console.error('Failed to update configuration:', error); throw error; } } // Get system reports async generateSystemReport( reportType: SystemReport['report_type'], period: SystemReport['period'], adminId: string ): Promise<SystemReport> { try { let reportData: any; const now = new Date(); const periodStart = this.getPeriodStart(period, now); const filters = { date_from: periodStart.toISOString(), date_to: now.toISOString() }; switch (reportType) { case 'users': reportData = await userManagementService.getUserStats(filters); break; case 'revenue': reportData = await analyticsService.getRevenueAnalytics(filters); break; case 'collaborations': const collaborations = await collaborationService.getCollaborations(filters); reportData = this.analyzeCollaborations(collaborations); break; case 'performance': reportData = await analyticsService.getPerformanceMetrics(); break; case 'security': reportData = await this.generateSecurityReport(filters); break; default: throw new Error('Invalid report type'); } const report: SystemReport = { report_type: reportType, period, data: reportData, generated_at: new Date().toISOString(), generated_by: adminId }; // Save report to database await supabase .from('system_reports') .insert({ type: reportType, period, data: reportData, generated_by: adminId, generated_at: new Date().toISOString() }); // Log report generation await auditService.logAdminAction( adminId, (await authService.getCurrentUser())?.user?.email || 'admin', `Generated ${reportType} report`, undefined, { report_type: reportType, period } ); return report; } catch (error) { console.error('Failed to generate system report:', error); throw error; } } // Moderate content/users async moderateContent( targetType: ModerationAction['target_type'], targetId: string, action: ModerationAction['action'], reason: string, adminId: string, details?: string, expiresAt?: string ): Promise<ModerationAction> { try { // Create moderation record const moderationAction: TablesInsert<'moderation_actions'> = { admin_id: adminId, target_type: targetType, target_id: targetId, action, reason, details, expires_at: expiresAt, created_at: new Date().toISOString() }; const { data, error } = await supabase .from('moderation_actions') .insert(moderationAction) .select() .single(); if (error) { throw error; } // Apply the moderation action await this.applyModerationAction(targetType, targetId, action, adminId, expiresAt); // Log moderation action await auditService.logAdminAction( adminId, (await authService.getCurrentUser())?.user?.email || 'admin', `Moderated ${targetType}`, targetId, { action, reason, details } ); return data; } catch (error) { console.error('Failed to moderate content:', error); throw error; } } // Get moderation queue async getModerationQueue(): Promise<Array<{ id: string; type: string; title: string; user: string; created_at: string; priority: 'low' | 'medium' | 'high'; status: 'pending' | 'reviewed' | 'approved' | 'rejected'; }>> { try { // This would query various tables for content requiring moderation // For now, return mock data return [ { id: '1', type: 'collaboration', title: 'Colaboraci√≥n sospechosa', user: 'usuario@example.com', created_at: new Date().toISOString(), priority: 'high', status: 'pending' }, { id: '2', type: 'user_profile', title: 'Perfil con contenido inapropiado', user: 'otro@example.com', created_at: new Date(Date.now() - 3600000).toISOString(), priority: 'medium', status: 'pending' } ]; } catch (error) { console.error('Failed to get moderation queue:', error); return []; } } // Manage platform features async toggleFeature( featureName: string, enabled: boolean, adminId: string ): Promise<void> { try { await this.updateConfiguration( `feature_${featureName}_enabled`, enabled, adminId ); // Notify users about feature changes if it's a major feature const majorFeatures = ['collaborations', 'payments', 'messaging']; if (majorFeatures.includes(featureName)) { await this.notifyFeatureChange(featureName, enabled); } } catch (error) { console.error('Failed to toggle feature:', error); throw error; } } // Handle platform maintenance async scheduleMaintenance( startTime: string, endTime: string, description: string, adminId: string ): Promise<void> { try { // Create maintenance record await supabase .from('maintenance_schedules') .insert({ start_time: startTime, end_time: endTime, description, scheduled_by: adminId, created_at: new Date().toISOString() }); // Notify all users about scheduled maintenance await this.notifyScheduledMaintenance(startTime, endTime, description); // Log maintenance scheduling await auditService.logAdminAction( adminId, (await authService.getCurrentUser())?.user?.email || 'admin', 'Scheduled maintenance', undefined, { start_time: startTime, end_time: endTime, description } ); } catch (error) { console.error('Failed to schedule maintenance:', error); throw error; } } // Get system health check async performHealthCheck(): Promise<{ overall_status: 'healthy' | 'warning' | 'critical'; services: Array<{ name: string; status: 'healthy' | 'warning' | 'critical'; response_time?: number; error?: string; }>; recommendations: string[]; }> { try { const services = []; const recommendations = []; // Check database const dbCheck = await this.checkDatabaseHealth(); services.push({ name: 'Database', status: dbCheck.status, response_time: dbCheck.responseTime, error: dbCheck.error }); // Check storage const storageCheck = await this.checkStorageHealth(); services.push({ name: 'Storage', status: storageCheck.status, error: storageCheck.error }); // Check external services const mercadoPagoCheck = await this.checkMercadoPagoHealth(); services.push({ name: 'MercadoPago', status: mercadoPagoCheck.status, error: mercadoPagoCheck.error }); // Determine overall status const criticalServices = services.filter(s => s.status === 'critical'); const warningServices = services.filter(s => s.status === 'warning'); let overallStatus: 'healthy' | 'warning' | 'critical' = 'healthy'; if (criticalServices.length > 0) { overallStatus = 'critical'; recommendations.push('Servicios cr√≠ticos requieren atenci√≥n inmediata'); } else if (warningServices.length > 0) { overallStatus = 'warning'; recommendations.push('Algunos servicios requieren moniteo'); } return { overall_status: overallStatus, services, recommendations }; } catch (error) { console.error('Health check failed:', error); return { overall_status: 'critical', services: [], recommendations: ['Error al realizar el chequeo de salud'] }; } } // Export admin data async exportAdminData( dataType: 'users' | 'collaborations' | 'payments' | 'audit_logs', filters: any = {}, format: 'csv' | 'json' = 'csv' ): Promise<string> { try { let data: any; switch (dataType) { case 'users': data = await userManagementService.exportUsers(filters, format); break; case 'collaborations': const collaborations = await collaborationService.getCollaborations(filters); data = format === 'json' ? JSON.stringify(collaborations, null, 2) : this.convertToCSV(collaborations); break; case 'payments': data = await paymentsService.exportPayments(filters); break; case 'audit_logs': data = await auditService.exportAuditLogs(filters, format); break; default: throw new Error('Invalid data type'); } return data; } catch (error) { console.error('Failed to export admin data:', error); throw error; } } // Private helper methods private getSystemHealthStatus(metrics: any): 'healthy' | 'warning' | 'critical' { if (metrics.error_rate > 5 || metrics.avg_response_time > 1000) { return 'critical'; } if (metrics.error_rate > 2 || metrics.avg_response_time > 500) { return 'warning'; } return 'healthy'; } private async getSystemAlerts(): Promise<AdminDashboardData['alerts']> { try { // In production, this would query an alerts table return [ { id: '1', type: 'performance', message: 'Tiempo de respuesta elevado detectado', severity: 'medium', created_at: new Date().toISOString(), resolved: false }, { id: '2', type: 'security', message: 'Intentos de login fallidos inusuales', severity: 'high', created_at: new Date(Date.now() - 1800000).toISOString(), resolved: false } ]; } catch (error) { console.error('Failed to get system alerts:', error); return []; } } private getPeriodStart(period: SystemReport['period'], now: Date): Date { const start = new Date(now); switch (period) { case 'daily': start.setHours(0, 0, 0, 0); break; case 'weekly': start.setDate(start.getDate() - 7); break; case 'monthly': start.setMonth(start.getMonth() - 1); break; case 'yearly': start.setFullYear(start.getFullYear() - 1); break; } return start; } private analyzeCollaborations(collaborations: any[]): any { return { total: collaborations.length, by_status: collaborations.reduce((acc, c) => { acc[c.status] = (acc[c.status] || 0) + 1; return acc; }, {}), by_type: collaborations.reduce((acc, c) => { acc[c.collaboration_type || 'unknown'] = (acc[c.collaboration_type || 'unknown'] || 0) + 1; return acc; }, {}), avg_value: collaborations.length > 0 ? collaborations.reduce((sum, c) => sum + (c.compensation_amount || 0), 0) / collaborations.length : 0 }; } private async generateSecurityReport(filters: any): Promise<any> { const auditEvents = await auditService.getAuditEvents({ ...filters, event_type: 'security_event' }, 1000); return { total_security_events: auditEvents.length, events_by_type: auditEvents.reduce((acc, e) => { acc[e.event_type] = (acc[e.event_type] || 0) + 1; return acc; }, {}), failed_logins: auditEvents.filter(e => e.event_type === 'login_failed').length, suspicious_activities: auditEvents.filter(e => e.severity === 'high' || e.severity === 'critical') }; } private async applyModerationAction( targetType: string, targetId: string, action: string, adminId: string, expiresAt?: string ): Promise<void> { try { switch (targetType) { case 'user': if (action === 'suspend') { await userManagementService.suspendUser({ user_id: targetId, reason: 'other', details: 'Suspended by admin moderation', suspended_by: adminId, duration_days: expiresAt ? this.calculateDurationDays(expiresAt) : undefined }); } break; case 'collaboration': if (action === 'reject') { await collaborationService.cancelCollaboration(targetId, 'Rejected by moderation'); } break; // Add more cases as needed } } catch (error) { console.error('Failed to apply moderation action:', error); } } private calculateDurationDays(expiresAt: string): number { const now = new Date(); const expires = new Date(expiresAt); const diffTime = expires.getTime() - now.getTime(); return Math.ceil(diffTime / (1000 * 60 * 60 * 24)); } private async notifyFeatureChange(featureName: string, enabled: boolean): Promise<void> { // This would send notifications to all users about feature changes console.log(`üì¢ Feature ${featureName} ${enabled ? 'enabled' : 'disabled'}`); } private async notifyScheduledMaintenance( startTime: string, endTime: string, description: string ): Promise<void> { // This would send maintenance notifications to all users console.log(`üîß Maintenance scheduled: ${startTime} - ${endTime}: ${description}`); } private async checkDatabaseHealth(): Promise<{ status: 'healthy' | 'warning' | 'critical'; responseTime?: number; error?: string; }> { try { const start = Date.now(); await supabase.from('users').select('count').limit(1); const responseTime = Date.now() - start; return { status: responseTime > 1000 ? 'warning' : 'healthy', responseTime }; } catch (error: any) { return { status: 'critical', error: error.message }; } } private async checkStorageHealth(): Promise<{ status: 'healthy' | 'warning' | 'critical'; error?: string; }> { try { // Test storage access await supabase.storage.from('files').list('', { limit: 1 }); return { status: 'healthy' }; } catch (error: any) { return { status: 'critical', error: error.message }; } } private async checkMercadoPagoHealth(): Promise<{ status: 'healthy' | 'warning' | 'critical'; error?: string; }> { try { // In production, this would ping MercadoPago API return { status: 'healthy' }; } catch (error: any) { return { status: 'warning', error: 'Cannot verify MercadoPago status' }; } } private convertToCSV(data: any[]): string { if (data.length === 0) return ''; const headers = Object.keys(data[0]); const rows = data.map(item => headers.map(header => `"${item[header] || ''}"`).join(',') ); return [headers.join(','), ...rows].join('\n'); } // Mock data methods private getMockDashboardData(): AdminDashboardData { return { platform_metrics: { total_users: 1245, active_users: 890, total_collaborations: 3456, revenue_today: 58000, revenue_month: 580000, growth_rate: 12.5 }, recent_activities: [ { id: '1', type: 'user_registration', description: 'Nuevo usuario registrado', user: 'nuevo@example.com', timestamp: new Date().toISOString(), severity: 'low' }, { id: '2', type: 'payment_completed', description: 'Pago completado', user: 'business@example.com', timestamp: new Date(Date.now() - 1800000).toISOString(), severity: 'low' } ], system_health: { status: 'healthy', uptime: 99.9, response_time: 245, error_rate: 0.5, active_connections: 150 }, alerts: [ { id: '1', type: 'performance', message: 'Tiempo de respuesta elevado detectado', severity: 'medium', created_at: new Date().toISOString(), resolved: false } ] }; } private getMockConfiguration(): PlatformConfiguration[] { return [ { id: '1', key: 'platform_commission_rate', value: 0.15, description: 'Platform commission rate (15%)', category: 'payments', data_type: 'number', is_public: false, created_at: new Date().toISOString(), updated_at: new Date().toISOString() }, { id: '2', key: 'max_file_upload_size', value: 10485760, description: 'Maximum file upload size in bytes (10MB)', category: 'general', data_type: 'number', is_public: true, created_at: new Date().toISOString(), updated_at: new Date().toISOString() } ]; }
} export const adminService = new AdminService();
export default adminService;