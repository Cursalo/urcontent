// Analytics Service
// Comprehensive analytics and metrics tracking import { supabase } from '@/integrations/supabase/client';
import { Tables } from '@/integrations/supabase/types';
import { collaborationService } from './collaborations';
import { paymentsService } from './payments';
import { userManagementService } from './userManagementService'; export interface PlatformMetrics { total_users: number; active_users_30d: number; total_collaborations: number; completed_collaborations: number; total_revenue: number; revenue_30d: number; avg_collaboration_value: number; completion_rate: number; user_growth_rate: number; revenue_growth_rate: number;
} export interface UserAnalytics { user_id: string; profile_views: number; collaboration_requests: number; completed_collaborations: number; total_earnings: number; avg_rating: number; response_rate: number; completion_rate: number; last_active: string; engagement_score: number;
} export interface RevenueAnalytics { total_revenue: number; platform_commission: number; creator_earnings: number; monthly_revenue: Array<{ month: string; revenue: number; commission: number }>; revenue_by_category: Record<string, number>; top_earners: Array<{ user_id: string; user_name: string; earnings: number }>; payment_methods: Record<string, { count: number; amount: number }>;
} export interface PerformanceMetrics { avg_response_time: number; error_rate: number; uptime_percentage: number; api_calls_per_minute: number; database_performance: { avg_query_time: number; slow_queries_count: number; connection_pool_usage: number; }; user_satisfaction: { avg_rating: number; support_tickets: number; resolution_time: number; };
} export interface EngagementMetrics { daily_active_users: number; weekly_active_users: number; monthly_active_users: number; session_duration: number; pages_per_session: number; bounce_rate: number; retention_rate: { day_1: number; day_7: number; day_30: number; }; feature_usage: Record<string, number>;
} export interface BusinessInsights { top_performing_categories: Array<{ category: string; collaboration_count: number; avg_value: number }>; seasonal_trends: Array<{ period: string; activity_level: number }>; market_opportunities: Array<{ category: string; demand_score: number; supply_score: number }>; user_segments: Array<{ segment: string; size: number; characteristics: string[] }>; conversion_funnels: { registration_to_profile: number; profile_to_first_collaboration: number; collaboration_to_completion: number; };
} export interface AnalyticsFilters { date_from?: string; date_to?: string; user_id?: string; business_id?: string; creator_id?: string; category?: string; platform?: string; status?: string;
} class AnalyticsService { private metricsCache = new Map<string, { data: any; timestamp: number; ttl: number }>(); private readonly CACHE_TTL = { realtime: 30000, // 30 seconds hourly: 3600000, // 1 hour daily: 86400000, // 24 hours }; // Get platform-wide metrics async getPlatformMetrics(filters: AnalyticsFilters = {}): Promise<PlatformMetrics> { const cacheKey = `platform_metrics_${JSON.stringify(filters)}`; const cached = this.getCachedData(cacheKey); if (cached) return cached; try { // Get user stats const userStats = await userManagementService.getUserStats(); // Get collaboration stats const collaborations = await collaborationService.getCollaborations(filters); const completedCollaborations = collaborations.filter(c => c.status === 'completed'); // Get payment stats const paymentStats = await paymentsService.getPaymentStats(); // Calculate growth rates const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString(); const recentUsers = await userManagementService.getUsers({ date_from: thirtyDaysAgo }); const metrics: PlatformMetrics = { total_users: userStats.total_users, active_users_30d: recentUsers.length, total_collaborations: collaborations.length, completed_collaborations: completedCollaborations.length, total_revenue: paymentStats.total_amount_approved, revenue_30d: this.calculateRecentRevenue(paymentStats, 30), avg_collaboration_value: this.calculateAverageCollaborationValue(collaborations), completion_rate: collaborations.length > 0 ? (completedCollaborations.length / collaborations.length) * 100 : 0, user_growth_rate: this.calculateGrowthRate(userStats.total_users, recentUsers.length), revenue_growth_rate: this.calculateRevenueGrowthRate(paymentStats) }; this.setCachedData(cacheKey, metrics, this.CACHE_TTL.hourly); return metrics; } catch (error) { console.error('Failed to get platform metrics:', error); return this.getMockPlatformMetrics(); } } // Get user-specific analytics async getUserAnalytics(userId: string, filters: AnalyticsFilters = {}): Promise<UserAnalytics> { const cacheKey = `user_analytics_${userId}_${JSON.stringify(filters)}`; const cached = this.getCachedData(cacheKey); if (cached) return cached; try { // Get user collaborations const collaborations = await collaborationService.getCreatorCollaborations(userId); const completedCollaborations = collaborations.filter(c => c.status === 'completed'); // Get user payments const payments = await paymentsService.getUserPayments(userId); const totalEarnings = payments .filter(p => p.status === 'approved') .reduce((sum, p) => sum + p.amount, 0); // Get user activity const activity = await userManagementService.getUserActivity(userId); const analytics: UserAnalytics = { user_id: userId, profile_views: 0, // TODO: Implement profile view tracking collaboration_requests: collaborations.length, completed_collaborations: completedCollaborations.length, total_earnings: totalEarnings, avg_rating: 4.5, // TODO: Calculate from reviews response_rate: this.calculateResponseRate(collaborations), completion_rate: collaborations.length > 0 ? (completedCollaborations.length / collaborations.length) * 100 : 0, last_active: activity.last_login || new Date().toISOString(), engagement_score: this.calculateEngagementScore({ collaborations: collaborations.length, completions: completedCollaborations.length, earnings: totalEarnings, loginCount: activity.login_count }) }; this.setCachedData(cacheKey, analytics, this.CACHE_TTL.hourly); return analytics; } catch (error) { console.error('Failed to get user analytics:', error); return this.getMockUserAnalytics(userId); } } // Get revenue analytics async getRevenueAnalytics(filters: AnalyticsFilters = {}): Promise<RevenueAnalytics> { const cacheKey = `revenue_analytics_${JSON.stringify(filters)}`; const cached = this.getCachedData(cacheKey); if (cached) return cached; try { const paymentStats = await paymentsService.getPaymentStats(filters); const payments = await paymentsService.getPayments(filters, 10000); // Calculate commission (assuming 15% platform fee) const PLATFORM_FEE = 0.15; const totalRevenue = paymentStats.total_amount_approved; const platformCommission = totalRevenue * PLATFORM_FEE; const creatorEarnings = totalRevenue - platformCommission; const analytics: RevenueAnalytics = { total_revenue: totalRevenue, platform_commission: platformCommission, creator_earnings: creatorEarnings, monthly_revenue: this.calculateMonthlyRevenue(payments), revenue_by_category: this.calculateRevenueByCategory(payments), top_earners: await this.getTopEarners(payments, 10), payment_methods: paymentStats.by_method }; this.setCachedData(cacheKey, analytics, this.CACHE_TTL.hourly); return analytics; } catch (error) { console.error('Failed to get revenue analytics:', error); return this.getMockRevenueAnalytics(); } } // Get performance metrics async getPerformanceMetrics(): Promise<PerformanceMetrics> { const cacheKey = 'performance_metrics'; const cached = this.getCachedData(cacheKey); if (cached) return cached; try { // These would be collected from monitoring systems in production const metrics: PerformanceMetrics = { avg_response_time: 245, // ms error_rate: 0.5, // % uptime_percentage: 99.9, api_calls_per_minute: 150, database_performance: { avg_query_time: 45, // ms slow_queries_count: 5, connection_pool_usage: 65 // % }, user_satisfaction: { avg_rating: 4.7, support_tickets: 12, resolution_time: 4.2 // hours } }; this.setCachedData(cacheKey, metrics, this.CACHE_TTL.realtime); return metrics; } catch (error) { console.error('Failed to get performance metrics:', error); return this.getMockPerformanceMetrics(); } } // Get engagement metrics async getEngagementMetrics(filters: AnalyticsFilters = {}): Promise<EngagementMetrics> { const cacheKey = `engagement_metrics_${JSON.stringify(filters)}`; const cached = this.getCachedData(cacheKey); if (cached) return cached; try { // Calculate active users for different periods const today = new Date(); const dayAgo = new Date(today.getTime() - 24 * 60 * 60 * 1000); const weekAgo = new Date(today.getTime() - 7 * 24 * 60 * 60 * 1000); const monthAgo = new Date(today.getTime() - 30 * 24 * 60 * 60 * 1000); const dailyActiveUsers = await this.getActiveUsersForPeriod(dayAgo.toISOString()); const weeklyActiveUsers = await this.getActiveUsersForPeriod(weekAgo.toISOString()); const monthlyActiveUsers = await this.getActiveUsersForPeriod(monthAgo.toISOString()); const metrics: EngagementMetrics = { daily_active_users: dailyActiveUsers, weekly_active_users: weeklyActiveUsers, monthly_active_users: monthlyActiveUsers, session_duration: 18.5, // minutes (mock data) pages_per_session: 7.2, bounce_rate: 25.4, // % retention_rate: { day_1: 75.2, day_7: 45.8, day_30: 23.1 }, feature_usage: { collaborations: 1250, messaging: 890, payments: 450, portfolio: 670 } }; this.setCachedData(cacheKey, metrics, this.CACHE_TTL.hourly); return metrics; } catch (error) { console.error('Failed to get engagement metrics:', error); return this.getMockEngagementMetrics(); } } // Get business insights async getBusinessInsights(filters: AnalyticsFilters = {}): Promise<BusinessInsights> { const cacheKey = `business_insights_${JSON.stringify(filters)}`; const cached = this.getCachedData(cacheKey); if (cached) return cached; try { const collaborations = await collaborationService.getCollaborations(filters); const insights: BusinessInsights = { top_performing_categories: this.analyzeTopCategories(collaborations), seasonal_trends: this.analyzeSeasonalTrends(collaborations), market_opportunities: this.identifyMarketOpportunities(collaborations), user_segments: await this.analyzeUserSegments(), conversion_funnels: await this.calculateConversionFunnels() }; this.setCachedData(cacheKey, insights, this.CACHE_TTL.daily); return insights; } catch (error) { console.error('Failed to get business insights:', error); return this.getMockBusinessInsights(); } } // Track custom event async trackEvent( userId: string, eventName: string, properties?: Record<string, any> ): Promise<void> { try { await supabase .from('analytics_events') .insert({ user_id: userId, event_name: eventName, properties, created_at: new Date().toISOString() }); } catch (error) { console.error('Failed to track event:', error); } } // Export analytics data async exportAnalytics( type: 'platform' | 'revenue' | 'users' | 'engagement', filters: AnalyticsFilters = {}, format: 'csv' | 'json' = 'csv' ): Promise<string> { try { let data: any; switch (type) { case 'platform': data = await this.getPlatformMetrics(filters); break; case 'revenue': data = await this.getRevenueAnalytics(filters); break; case 'users': data = await userManagementService.getUserStats(); break; case 'engagement': data = await this.getEngagementMetrics(filters); break; default: throw new Error('Invalid analytics type'); } if (format === 'json') { return JSON.stringify(data, null, 2); } // Convert to CSV (simplified) const flatData = this.flattenObject(data); const headers = Object.keys(flatData); const values = Object.values(flatData); return [headers, values] .map(row => row.map(field => `"${field}"`).join(',')) .join('\n'); } catch (error) { console.error('Failed to export analytics:', error); throw error; } } // Helper methods private getCachedData(key: string): any | null { const cached = this.metricsCache.get(key); if (cached && Date.now() - cached.timestamp < cached.ttl) { return cached.data; } return null; } private setCachedData(key: string, data: any, ttl: number): void { this.metricsCache.set(key, { data, timestamp: Date.now(), ttl }); } private calculateRecentRevenue(paymentStats: any, days: number): number { // This would query payments from the last N days return paymentStats.total_amount_approved * 0.3; // Mock: 30% recent } private calculateAverageCollaborationValue(collaborations: any[]): number { if (collaborations.length === 0) return 0; const total = collaborations.reduce((sum, c) => sum + (c.compensation_amount || 0), 0); return total / collaborations.length; } private calculateGrowthRate(total: number, recent: number): number { if (total === 0) return 0; return (recent / total) * 100; } private calculateRevenueGrowthRate(paymentStats: any): number { // Mock calculation - in production, compare with previous period return 15.4; // 15.4% growth } private calculateResponseRate(collaborations: any[]): number { // Mock calculation - percentage of collaborations responded to within 24h return 87.5; } private calculateEngagementScore(data: { collaborations: number; completions: number; earnings: number; loginCount: number; }): number { // Weighted engagement score const weights = { collaborations: 0.3, completions: 0.4, earnings: 0.2, logins: 0.1 }; const normalizedScore = (Math.min(data.collaborations, 100) / 100) * weights.collaborations + (Math.min(data.completions, 50) / 50) * weights.completions + (Math.min(data.earnings, 100000) / 100000) * weights.earnings + (Math.min(data.loginCount, 100) / 100) * weights.logins; return Math.round(normalizedScore * 100); } private calculateMonthlyRevenue(payments: any[]): Array<{ month: string; revenue: number; commission: number }> { const monthlyData: Record<string, { revenue: number; commission: number }> = {}; payments.forEach(payment => { if (payment.status === 'approved' && payment.created_at) { const month = payment.created_at.substring(0, 7); // YYYY-MM if (!monthlyData[month]) { monthlyData[month] = { revenue: 0, commission: 0 }; } monthlyData[month].revenue += payment.amount; monthlyData[month].commission += payment.amount * 0.15; // 15% commission } }); return Object.entries(monthlyData) .map(([month, data]) => ({ month, ...data })) .sort((a, b) => a.month.localeCompare(b.month)); } private calculateRevenueByCategory(payments: any[]): Record<string, number> { const categoryRevenue: Record<string, number> = {}; payments.forEach(payment => { if (payment.status === 'approved') { const category = payment.type || 'other'; categoryRevenue[category] = (categoryRevenue[category] || 0) + payment.amount; } }); return categoryRevenue; } private async getTopEarners(payments: any[], limit: number): Promise<Array<{ user_id: string; user_name: string; earnings: number }>> { const userEarnings: Record<string, number> = {}; payments.forEach(payment => { if (payment.status === 'approved') { userEarnings[payment.user_id] = (userEarnings[payment.user_id] || 0) + payment.amount; } }); const topEarners = Object.entries(userEarnings) .map(([userId, earnings]) => ({ user_id: userId, user_name: `User ${userId}`, earnings })) .sort((a, b) => b.earnings - a.earnings) .slice(0, limit); return topEarners; } private async getActiveUsersForPeriod(since: string): Promise<number> { // This would query user activity logs in production // For now, return mock data return Math.floor(Math.random() * 1000) + 500; } private analyzeTopCategories(collaborations: any[]): Array<{ category: string; collaboration_count: number; avg_value: number }> { const categoryStats: Record<string, { count: number; totalValue: number }> = {}; collaborations.forEach(collab => { const category = collab.collaboration_type || 'general'; if (!categoryStats[category]) { categoryStats[category] = { count: 0, totalValue: 0 }; } categoryStats[category].count++; categoryStats[category].totalValue += collab.compensation_amount || 0; }); return Object.entries(categoryStats) .map(([category, stats]) => ({ category, collaboration_count: stats.count, avg_value: stats.count > 0 ? stats.totalValue / stats.count : 0 })) .sort((a, b) => b.collaboration_count - a.collaboration_count) .slice(0, 10); } private analyzeSeasonalTrends(collaborations: any[]): Array<{ period: string; activity_level: number }> { // Mock seasonal analysis return [ { period: 'Q1', activity_level: 75 }, { period: 'Q2', activity_level: 95 }, { period: 'Q3', activity_level: 120 }, { period: 'Q4', activity_level: 140 } ]; } private identifyMarketOpportunities(collaborations: any[]): Array<{ category: string; demand_score: number; supply_score: number }> { // Mock market opportunity analysis return [ { category: 'Beauty & Cosmetics', demand_score: 85, supply_score: 45 }, { category: 'Fitness & Health', demand_score: 78, supply_score: 60 }, { category: 'Food & Restaurants', demand_score: 92, supply_score: 75 } ]; } private async analyzeUserSegments(): Promise<Array<{ segment: string; size: number; characteristics: string[] }>> { // Mock segmentation analysis return [ { segment: 'Active Creators', size: 450, characteristics: ['High completion rate', 'Regular posting', '4.5+ rating'] }, { segment: 'Growth Businesses', size: 180, characteristics: ['Multiple campaigns', 'High budget', 'Long-term partnerships'] } ]; } private async calculateConversionFunnels(): Promise<{ registration_to_profile: number; profile_to_first_collaboration: number; collaboration_to_completion: number }> { // Mock conversion funnel data return { registration_to_profile: 85.2, profile_to_first_collaboration: 42.8, collaboration_to_completion: 78.5 }; } private flattenObject(obj: any, prefix: string = ''): Record<string, any> { const flattened: Record<string, any> = {}; for (const key in obj) { if (obj.hasOwnProperty(key)) { const newKey = prefix ? `${prefix}.${key}` : key; if (obj[key] && typeof obj[key] === 'object' && !Array.isArray(obj[key])) { Object.assign(flattened, this.flattenObject(obj[key], newKey)); } else { flattened[newKey] = obj[key]; } } } return flattened; } // Mock data methods private getMockPlatformMetrics(): PlatformMetrics { return { total_users: 1245, active_users_30d: 890, total_collaborations: 3456, completed_collaborations: 2879, total_revenue: 2450000, // $24,500 revenue_30d: 580000, // $5,800 avg_collaboration_value: 85000, // $850 completion_rate: 83.3, user_growth_rate: 12.5, revenue_growth_rate: 18.2 }; } private getMockUserAnalytics(userId: string): UserAnalytics { return { user_id: userId, profile_views: 1250, collaboration_requests: 45, completed_collaborations: 38, total_earnings: 125000, // $1,250 avg_rating: 4.7, response_rate: 92.5, completion_rate: 84.4, last_active: new Date().toISOString(), engagement_score: 87 }; } private getMockRevenueAnalytics(): RevenueAnalytics { return { total_revenue: 2450000, platform_commission: 367500, creator_earnings: 2082500, monthly_revenue: [ { month: '2024-01', revenue: 180000, commission: 27000 }, { month: '2024-02', revenue: 220000, commission: 33000 }, { month: '2024-03', revenue: 290000, commission: 43500 } ], revenue_by_category: { collaboration: 1850000, experience: 450000, membership: 150000 }, top_earners: [ { user_id: '1', user_name: 'Top Creator 1', earnings: 45000 }, { user_id: '2', user_name: 'Top Creator 2', earnings: 38000 } ], payment_methods: { MercadoPago: { count: 1250, amount: 2200000 }, 'Credit Card': { count: 300, amount: 250000 } } }; } private getMockPerformanceMetrics(): PerformanceMetrics { return { avg_response_time: 245, error_rate: 0.5, uptime_percentage: 99.9, api_calls_per_minute: 150, database_performance: { avg_query_time: 45, slow_queries_count: 5, connection_pool_usage: 65 }, user_satisfaction: { avg_rating: 4.7, support_tickets: 12, resolution_time: 4.2 } }; } private getMockEngagementMetrics(): EngagementMetrics { return { daily_active_users: 450, weekly_active_users: 890, monthly_active_users: 1180, session_duration: 18.5, pages_per_session: 7.2, bounce_rate: 25.4, retention_rate: { day_1: 75.2, day_7: 45.8, day_30: 23.1 }, feature_usage: { collaborations: 1250, messaging: 890, payments: 450, portfolio: 670 } }; } private getMockBusinessInsights(): BusinessInsights { return { top_performing_categories: [ { category: 'Beauty & Cosmetics', collaboration_count: 145, avg_value: 95000 }, { category: 'Food & Restaurants', collaboration_count: 123, avg_value: 75000 } ], seasonal_trends: [ { period: 'Q1', activity_level: 75 }, { period: 'Q2', activity_level: 95 }, { period: 'Q3', activity_level: 120 }, { period: 'Q4', activity_level: 140 } ], market_opportunities: [ { category: 'Beauty & Cosmetics', demand_score: 85, supply_score: 45 }, { category: 'Fitness & Health', demand_score: 78, supply_score: 60 } ], user_segments: [ { segment: 'Active Creators', size: 450, characteristics: ['High completion rate', 'Regular posting', '4.5+ rating'] } ], conversion_funnels: { registration_to_profile: 85.2, profile_to_first_collaboration: 42.8, collaboration_to_completion: 78.5 } }; }
} export const analyticsService = new AnalyticsService();
export default analyticsService;