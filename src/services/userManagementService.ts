// User Management Service
// Comprehensive user management with admin controls import { supabase } from '@/integrations/supabase/client';
import { Tables, TablesInsert, TablesUpdate } from '@/integrations/supabase/types';
import { profileService } from './profileService';
import { notificationService } from './notifications';
import { auditService } from './auditService';
import { authService } from './authService'; export type UserStatus = 'active' | 'suspended' | 'banned' | 'pending_verification';
export type SuspensionReason = 'policy_violation' | 'spam' | 'inappropriate_content' | 'fraud' | 'other'; export interface UserProfile extends Tables<'users'> { creator_profile?: Tables<'creator_profiles'>; business_profile?: Tables<'business_profiles'>; last_login?: string; login_count?: number; status?: UserStatus;
} export interface UserFilters { role?: 'creator' | 'business' | 'admin'; status?: UserStatus; verified?: boolean; date_from?: string; date_to?: string; search_term?: string; has_collaborations?: boolean; has_payments?: boolean; is_suspended?: boolean;
} export interface UserStats { total_users: number; active_users: number; suspended_users: number; verified_users: number; creators_count: number; businesses_count: number; admins_count: number; recent_signups: number; users_by_month: Array<{ month: string; count: number }>; top_creators: Array<{ user: UserProfile; collaboration_count: number }>; top_businesses: Array<{ user: UserProfile; campaign_count: number }>;
} export interface SuspensionData { user_id: string; reason: SuspensionReason; details: string; duration_days?: number; // null for permanent suspended_by: string;
} export interface UserVerificationData { user_id: string; verification_type: 'email' | 'identity' | 'business'; verified_by: string; verification_notes?: string;
} class UserManagementService { // Get all users with filtering and pagination async getUsers( filters: UserFilters = {}, limit: number = 50, offset: number = 0 ): Promise<UserProfile[]> { try { let query = supabase .from('users') .select(` *, creator_profile:creator_profiles(*), business_profile:business_profiles(*) `); // Apply filters if (filters.role) { query = query.eq('role', filters.role); } if (filters.verified !== undefined) { query = query.eq('is_verified', filters.verified); } if (filters.date_from) { query = query.gte('created_at', filters.date_from); } if (filters.date_to) { query = query.lte('created_at', filters.date_to); } if (filters.search_term) { query = query.or( `full_name.ilike.%${filters.search_term}%,email.ilike.%${filters.search_term}%` ); } const { data, error } = await query .order('created_at', { ascending: false }) .range(offset, offset + limit - 1); if (error) { console.error('Error fetching users:', error); throw error; } return data || []; } catch (error) { console.error('Failed to fetch users:', error); return this.getMockUsers(filters, limit); } } // Get single user by ID with full profile async getUser(userId: string): Promise<UserProfile | null> { try { const { data, error } = await supabase .from('users') .select(` *, creator_profile:creator_profiles(*), business_profile:business_profiles(*) `) .eq('id', userId) .single(); if (error) { if (error.code === 'PGRST116') { return null; } throw error; } return data; } catch (error) { console.error('Failed to fetch user:', error); return null; } } // Update user profile (admin action) async updateUser( userId: string, updates: TablesUpdate<'users'>, adminId: string ): Promise<UserProfile> { try { const { data, error } = await supabase .from('users') .update({ ...updates, updated_at: new Date().toISOString() }) .eq('id', userId) .select(` *, creator_profile:creator_profiles(*), business_profile:business_profiles(*) `) .single(); if (error) { throw error; } // Log admin action await auditService.logAdminAction( adminId, (await authService.getCurrentUser())?.user?.email || 'admin', 'Updated user profile', userId, { updates } ); // Notify user of profile changes await notificationService.createNotification({ user_id: userId, title: 'Perfil Actualizado', message: 'Tu perfil ha sido actualizado por un administrador.', type: 'profile_update', is_read: false }); return data; } catch (error) { console.error('Failed to update user:', error); throw error; } } // Suspend user account async suspendUser(suspensionData: SuspensionData): Promise<void> { const { user_id, reason, details, duration_days, suspended_by } = suspensionData; try { const suspendedUntil = duration_days ? new Date(Date.now() + duration_days * 24 * 60 * 60 * 1000).toISOString() : null; // Update user status await supabase .from('users') .update({ is_suspended: true, suspended_until: suspendedUntil, suspension_reason: reason, updated_at: new Date().toISOString() }) .eq('id', user_id); // Create suspension record await supabase .from('user_suspensions') .insert({ user_id, reason, details, duration_days, suspended_by, suspended_at: new Date().toISOString(), expires_at: suspendedUntil }); // Log admin action await auditService.logAdminAction( suspended_by, (await authService.getCurrentUser())?.user?.email || 'admin', 'Suspended user account', user_id, { reason, details, duration_days } ); // Notify user await notificationService.createNotification({ user_id, title: 'Cuenta Suspendida', message: `Tu cuenta ha sido suspendida${duration_days ? ` por ${duration_days} d√≠as` : ' permanentemente'}. Raz√≥n: ${details}`, type: 'account_suspended', is_read: false }); console.log(`‚úÖ User ${user_id} suspended for ${reason}`); } catch (error) { console.error('Failed to suspend user:', error); throw error; } } // Reactivate suspended user async reactivateUser(userId: string, adminId: string, notes?: string): Promise<void> { try { // Update user status await supabase .from('users') .update({ is_suspended: false, suspended_until: null, suspension_reason: null, updated_at: new Date().toISOString() }) .eq('id', userId); // Update suspension record await supabase .from('user_suspensions') .update({ reactivated_at: new Date().toISOString(), reactivated_by: adminId, reactivation_notes: notes }) .eq('user_id', userId) .is('reactivated_at', null); // Log admin action await auditService.logAdminAction( adminId, (await authService.getCurrentUser())?.user?.email || 'admin', 'Reactivated user account', userId, { notes } ); // Notify user await notificationService.createNotification({ user_id: userId, title: 'Cuenta Reactivada', message: 'Tu cuenta ha sido reactivada. Ya puedes acceder nuevamente a URContent.', type: 'account_reactivated', is_read: false }); console.log(`‚úÖ User ${userId} reactivated`); } catch (error) { console.error('Failed to reactivate user:', error); throw error; } } // Verify user account async verifyUser(verificationData: UserVerificationData): Promise<void> { const { user_id, verification_type, verified_by, verification_notes } = verificationData; try { // Update user verification status const updateData: any = { is_verified: true, verified_at: new Date().toISOString(), updated_at: new Date().toISOString() }; if (verification_type === 'email') { updateData.email_verified = true; } else if (verification_type === 'identity') { updateData.identity_verified = true; } else if (verification_type === 'business') { updateData.business_verified = true; } await supabase .from('users') .update(updateData) .eq('id', user_id); // Create verification record await supabase .from('user_verifications') .insert({ user_id, verification_type, verified_by, verification_notes, verified_at: new Date().toISOString() }); // Log admin action await auditService.logAdminAction( verified_by, (await authService.getCurrentUser())?.user?.email || 'admin', `Verified user - ${verification_type}`, user_id, { verification_type, verification_notes } ); // Notify user await notificationService.notifyProfileVerification(user_id, true); console.log(`‚úÖ User ${user_id} verified for ${verification_type}`); } catch (error) { console.error('Failed to verify user:', error); throw error; } } // Reject user verification async rejectVerification( userId: string, verificationType: 'email' | 'identity' | 'business', adminId: string, reason: string ): Promise<void> { try { // Create verification record with rejection await supabase .from('user_verifications') .insert({ user_id: userId, verification_type: verificationType, verified_by: adminId, verification_notes: reason, verified_at: new Date().toISOString(), is_approved: false }); // Log admin action await auditService.logAdminAction( adminId, (await authService.getCurrentUser())?.user?.email || 'admin', `Rejected verification - ${verificationType}`, userId, { verification_type: verificationType, reason } ); // Notify user await notificationService.notifyProfileVerification(userId, false); console.log(`‚ùå User ${userId} verification rejected for ${verificationType}`); } catch (error) { console.error('Failed to reject verification:', error); throw error; } } // Delete user account (GDPR compliance) async deleteUser(userId: string, adminId: string, reason: string): Promise<void> { try { // Get user data before deletion for audit const user = await this.getUser(userId); if (!user) { throw new Error('User not found'); } // Soft delete - mark as deleted but keep for audit await supabase .from('users') .update({ is_deleted: true, deleted_at: new Date().toISOString(), deleted_by: adminId, deletion_reason: reason, // Anonymize sensitive data email: `deleted_${userId}@example.com`, full_name: `Deleted User ${userId}`, updated_at: new Date().toISOString() }) .eq('id', userId); // Log admin action await auditService.logAdminAction( adminId, (await authService.getCurrentUser())?.user?.email || 'admin', 'Deleted user account', userId, { reason, user_email: user.email, user_name: user.full_name } ); console.log(`üóëÔ∏è User ${userId} deleted by admin ${adminId}`); } catch (error) { console.error('Failed to delete user:', error); throw error; } } // Get user statistics async getUserStats(filters: UserFilters = {}): Promise<UserStats> { try { const users = await this.getUsers(filters, 10000); // Large dataset for stats const now = new Date(); const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000); const stats: UserStats = { total_users: users.length, active_users: users.filter(u => !u.is_suspended && !u.is_deleted).length, suspended_users: users.filter(u => u.is_suspended).length, verified_users: users.filter(u => u.is_verified).length, creators_count: users.filter(u => u.role === 'creator').length, businesses_count: users.filter(u => u.role === 'business').length, admins_count: users.filter(u => u.role === 'admin').length, recent_signups: users.filter(u => new Date(u.created_at!) > thirtyDaysAgo ).length, users_by_month: this.calculateUsersByMonth(users), top_creators: [], // TODO: Calculate based on collaborations top_businesses: [] // TODO: Calculate based on campaigns }; return stats; } catch (error) { console.error('Failed to get user stats:', error); return this.getMockUserStats(); } } // Search users with advanced filtering async searchUsers( searchTerm: string, filters: UserFilters = {}, limit: number = 50 ): Promise<UserProfile[]> { return this.getUsers({ ...filters, search_term: searchTerm }, limit); } // Get suspended users async getSuspendedUsers(limit: number = 50): Promise<UserProfile[]> { return this.getUsers({ is_suspended: true }, limit); } // Get users pending verification async getUsersPendingVerification(limit: number = 50): Promise<UserProfile[]> { return this.getUsers({ verified: false }, limit); } // Get user activity summary async getUserActivity(userId: string): Promise<{ last_login: string | null; login_count: number; collaborations_count: number; payments_count: number; notifications_count: number; recent_actions: any[]; }> { try { // Get user activity from audit logs const auditEvents = await auditService.getAuditEvents({ user_id: userId }, 100); // Calculate activity metrics const loginEvents = auditEvents.filter(e => e.event_type === 'login_success'); const lastLogin = loginEvents.length > 0 ? loginEvents[0].created_at : null; const loginCount = loginEvents.length; // Get collaboration and payment counts from respective services // TODO: Implement these counts from collaboration and payment services return { last_login: lastLogin, login_count: loginCount, collaborations_count: 0, // TODO payments_count: 0, // TODO notifications_count: 0, // TODO recent_actions: auditEvents.slice(0, 20) }; } catch (error) { console.error('Failed to get user activity:', error); return { last_login: null, login_count: 0, collaborations_count: 0, payments_count: 0, notifications_count: 0, recent_actions: [] }; } } // Export users data async exportUsers( filters: UserFilters = {}, format: 'csv' | 'json' = 'csv' ): Promise<string> { const users = await this.getUsers(filters, 10000); if (format === 'json') { return JSON.stringify(users, null, 2); } // CSV format const headers = [ 'ID', 'Email', 'Full Name', 'Role', 'Verified', 'Suspended', 'Created At', 'Last Updated', 'Login Count' ]; const rows = users.map(user => [ user.id, user.email || '', user.full_name || '', user.role || '', user.is_verified ? 'Yes' : 'No', user.is_suspended ? 'Yes' : 'No', user.created_at || '', user.updated_at || '', '0' // TODO: Get login count ]); return [headers, ...rows] .map(row => row.map(field => `"${field}"`).join(',')) .join('\n'); } // Helper methods private calculateUsersByMonth(users: UserProfile[]): Array<{ month: string; count: number }> { const monthCounts: Record<string, number> = {}; users.forEach(user => { if (user.created_at) { const month = new Date(user.created_at).toISOString().substring(0, 7); // YYYY-MM monthCounts[month] = (monthCounts[month] || 0) + 1; } }); return Object.entries(monthCounts) .map(([month, count]) => ({ month, count })) .sort((a, b) => a.month.localeCompare(b.month)); } // Mock data for development private getMockUsers(filters: UserFilters, limit: number): UserProfile[] { const mockUsers: UserProfile[] = [ { id: '1', email: 'creator@test.com', full_name: 'Test Creator', role: 'creator', is_verified: true, is_suspended: false, created_at: new Date().toISOString(), updated_at: new Date().toISOString() }, { id: '2', email: 'business@test.com', full_name: 'Test Business', role: 'business', is_verified: false, is_suspended: false, created_at: new Date(Date.now() - 86400000).toISOString(), updated_at: new Date(Date.now() - 86400000).toISOString() } ]; return mockUsers.slice(0, limit); } private getMockUserStats(): UserStats { return { total_users: 1245, active_users: 1180, suspended_users: 15, verified_users: 890, creators_count: 780, businesses_count: 420, admins_count: 5, recent_signups: 45, users_by_month: [ { month: '2024-01', count: 120 }, { month: '2024-02', count: 145 }, { month: '2024-03', count: 165 } ], top_creators: [], top_businesses: [] }; }
} export const userManagementService = new UserManagementService();
export default userManagementService;