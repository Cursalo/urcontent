import { supabase } from '@/integrations/supabase/client';
import { Tables, TablesInsert, TablesUpdate, Enums } from '@/integrations/supabase/types';
import { mockCollaborations, MockCollaboration } from '@/data/mockUsers'; export type Collaboration = Tables<'collaborations'> & { business_profile: Tables<'business_profiles'> & { user: Tables<'users'>; }; creator_profile?: (Tables<'creator_profiles'> & { user: Tables<'users'>; }) | null;
}; // Environment flag for using mock data
const USE_MOCK_DATA = import.meta.env.VITE_USE_MOCK_DATA === 'true' || window.location.hostname === 'localhost' || !import.meta.env.VITE_SUPABASE_URL; export type CollaborationFilters = { status?: Enums<'collaboration_status'>; collaboration_type?: string; platform?: string; search?: string; business_id?: string; creator_id?: string; date_from?: string; date_to?: string;
}; class CollaborationService { // Get all collaborations with filters async getCollaborations(filters: CollaborationFilters = {}): Promise<Collaboration[] | MockCollaboration[]> { if (USE_MOCK_DATA) { console.log('Using mock data for getCollaborations with filters:', filters); let filteredCollaborations = [...mockCollaborations]; // Apply filters if (filters.status) { filteredCollaborations = filteredCollaborations.filter(c => c.status === filters.status); } if (filters.business_id) { filteredCollaborations = filteredCollaborations.filter(c => c.business_id === filters.business_id); } if (filters.creator_id) { filteredCollaborations = filteredCollaborations.filter(c => c.creator_id === filters.creator_id); } if (filters.search) { const searchLower = filters.search.toLowerCase(); filteredCollaborations = filteredCollaborations.filter(c => c.title.toLowerCase().includes(searchLower) || c.description.toLowerCase().includes(searchLower) ); } if (filters.date_from) { filteredCollaborations = filteredCollaborations.filter(c => new Date(c.created_at) >= new Date(filters.date_from!) ); } if (filters.date_to) { filteredCollaborations = filteredCollaborations.filter(c => new Date(c.created_at) <= new Date(filters.date_to!) ); } // Sort by created_at descending filteredCollaborations.sort((a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime() ); console.log('Mock collaborations found:', filteredCollaborations); return filteredCollaborations; } try { let query = supabase .from('collaborations') .select(` *, business_profile:business_profiles( *, user:users(*) ), creator_profile:creator_profiles( *, user:users(*) ) `); // Apply filters if (filters.status) { query = query.eq('status', filters.status); } if (filters.collaboration_type) { query = query.eq('collaboration_type', filters.collaboration_type); } if (filters.platform) { query = query.eq('platform', filters.platform); } if (filters.business_id) { query = query.eq('business_id', filters.business_id); } if (filters.creator_id) { query = query.eq('creator_id', filters.creator_id); } if (filters.search) { query = query.or( `title.ilike.%${filters.search}%,description.ilike.%${filters.search}%` ); } if (filters.date_from) { query = query.gte('created_at', filters.date_from); } if (filters.date_to) { query = query.lte('created_at', filters.date_to); } const { data, error } = await query.order('created_at', { ascending: false }); if (error) { console.error('Error fetching collaborations:', error); throw error; } return data || []; } catch (error) { console.error('Supabase error, falling back to mock data:', error); // Fallback to mock data let filteredCollaborations = [...mockCollaborations]; if (filters.creator_id) { filteredCollaborations = filteredCollaborations.filter(c => c.creator_id === filters.creator_id); } return filteredCollaborations; } } // Get single collaboration by ID async getCollaboration(id: string): Promise<Collaboration | null> { const { data, error } = await supabase .from('collaborations') .select(` *, business_profile:business_profiles( *, user:users(*) ), creator_profile:creator_profiles( *, user:users(*) ) `) .eq('id', id) .single(); if (error) { console.error('Error fetching collaboration:', error); if (error.code === 'PGRST116') { return null; } throw error; } return data; } // Create new collaboration/campaign async createCollaboration( collaborationData: TablesInsert<'collaborations'> ): Promise<Collaboration> { const { data, error } = await supabase .from('collaborations') .insert(collaborationData) .select(` *, business_profile:business_profiles( *, user:users(*) ), creator_profile:creator_profiles( *, user:users(*) ) `) .single(); if (error) { console.error('Error creating collaboration:', error); throw error; } return data; } // Update collaboration async updateCollaboration( id: string, updates: TablesUpdate<'collaborations'> ): Promise<Collaboration> { const { data, error } = await supabase .from('collaborations') .update({ ...updates, updated_at: new Date().toISOString(), }) .eq('id', id) .select(` *, business_profile:business_profiles( *, user:users(*) ), creator_profile:creator_profiles( *, user:users(*) ) `) .single(); if (error) { console.error('Error updating collaboration:', error); throw error; } return data; } // Accept collaboration (creator accepts business proposal) async acceptCollaboration(id: string, creatorResponse?: string): Promise<Collaboration> { const updates: TablesUpdate<'collaborations'> = { status: 'accepted', accepted_at: new Date().toISOString(), }; if (creatorResponse) { updates.creator_response = creatorResponse; } return this.updateCollaboration(id, updates); } // Start collaboration (move to in_progress) async startCollaboration(id: string): Promise<Collaboration> { return this.updateCollaboration(id, { status: 'in_progress', }); } // Complete collaboration async completeCollaboration(id: string): Promise<Collaboration> { return this.updateCollaboration(id, { status: 'completed', completed_at: new Date().toISOString(), }); } // Cancel collaboration async cancelCollaboration(id: string, reason?: string): Promise<Collaboration> { const updates: TablesUpdate<'collaborations'> = { status: 'cancelled', }; if (reason) { updates.creator_response = reason; } return this.updateCollaboration(id, updates); } // Get collaborations for a specific business async getBusinessCollaborations(businessId: string): Promise<Collaboration[]> { return this.getCollaborations({ business_id: businessId }); } // Get collaborations for a specific creator async getCreatorCollaborations(creatorId: string): Promise<Collaboration[]> { return this.getCollaborations({ creator_id: creatorId }); } // Get pending collaborations for a creator async getPendingCollaborationsForCreator(creatorId: string): Promise<Collaboration[]> { return this.getCollaborations({ creator_id: creatorId, status: 'proposed' }); } // Get active collaborations for a business async getActiveBusinessCollaborations(businessId: string): Promise<Collaboration[]> { const { data, error } = await supabase .from('collaborations') .select(` *, business_profile:business_profiles( *, user:users(*) ), creator_profile:creator_profiles( *, user:users(*) ) `) .eq('business_id', businessId) .in('status', ['accepted', 'in_progress']) .order('created_at', { ascending: false }); if (error) { console.error('Error fetching active business collaborations:', error); throw error; } return data || []; } // Search available collaborations (for creators to find opportunities) async searchAvailableCollaborations( query?: string, filters?: { collaboration_type?: string; platform?: string; min_compensation?: number; max_compensation?: number; } ): Promise<Collaboration[]> { let supabaseQuery = supabase .from('collaborations') .select(` *, business_profile:business_profiles( *, user:users(*) ) `) .eq('status', 'proposed') .is('creator_id', null); // Open collaborations if (query) { supabaseQuery = supabaseQuery.or( `title.ilike.%${query}%,description.ilike.%${query}%` ); } if (filters?.collaboration_type) { supabaseQuery = supabaseQuery.eq('collaboration_type', filters.collaboration_type); } if (filters?.platform) { supabaseQuery = supabaseQuery.eq('platform', filters.platform); } if (filters?.min_compensation) { supabaseQuery = supabaseQuery.gte('compensation_amount', filters.min_compensation); } if (filters?.max_compensation) { supabaseQuery = supabaseQuery.lte('compensation_amount', filters.max_compensation); } const { data, error } = await supabaseQuery.order('created_at', { ascending: false }); if (error) { console.error('Error searching available collaborations:', error); throw error; } return data || []; } // Apply to collaboration (creator applies to business collaboration) async applyToCollaboration( collaborationId: string, creatorId: string, proposalMessage?: string ): Promise<Collaboration> { const updates: TablesUpdate<'collaborations'> = { creator_id: creatorId, status: 'proposed', }; if (proposalMessage) { updates.creator_response = proposalMessage; } return this.updateCollaboration(collaborationId, updates); } // Get collaboration statistics for a business async getBusinessCollaborationStats(businessId: string): Promise<{ total: number; active: number; completed: number; cancelled: number; totalSpent: number; avgRating: number; }> { const { data, error } = await supabase .from('collaborations') .select('status, compensation_amount') .eq('business_id', businessId); if (error) { console.error('Error fetching business collaboration stats:', error); throw error; } const stats = { total: data.length, active: data.filter(c => ['accepted', 'in_progress'].includes(c.status || '')).length, completed: data.filter(c => c.status === 'completed').length, cancelled: data.filter(c => c.status === 'cancelled').length, totalSpent: data.reduce((sum, c) => sum + (c.compensation_amount || 0), 0), avgRating: 0, // TODO: Calculate from reviews }; return stats; } // Get collaboration statistics for a creator async getCreatorCollaborationStats(creatorId: string): Promise<{ total: number; completed: number; active: number; totalEarned: number; avgRating: number; successRate: number; }> { const { data, error } = await supabase .from('collaborations') .select('status, compensation_amount') .eq('creator_id', creatorId); if (error) { console.error('Error fetching creator collaboration stats:', error); throw error; } const completed = data.filter(c => c.status === 'completed').length; const total = data.length; const stats = { total, completed, active: data.filter(c => ['accepted', 'in_progress'].includes(c.status || '')).length, totalEarned: data .filter(c => c.status === 'completed') .reduce((sum, c) => sum + (c.compensation_amount || 0), 0), avgRating: 0, // TODO: Calculate from reviews successRate: total > 0 ? (completed / total) * 100 : 0, }; return stats; } // Delete collaboration (only allowed if not started) async deleteCollaboration(id: string): Promise<void> { const { error } = await supabase .from('collaborations') .delete() .eq('id', id) .in('status', ['proposed', 'cancelled']); if (error) { console.error('Error deleting collaboration:', error); throw error; } }
} export const collaborationService = new CollaborationService();