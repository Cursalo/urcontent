// Enhanced Business Service
// Extended business management with campaign and ROI analytics import { supabase } from '@/integrations/supabase/client';
import { Tables, TablesInsert, TablesUpdate } from '@/integrations/supabase/types';
import { collaborationService } from './collaborations';
import { paymentsService } from './payments';
import { analyticsService } from './analyticsService';
import { enhancedCreatorsService } from './enhancedCreatorsService';
import { auditService } from './auditService';
import { notificationService } from './notifications'; export interface BusinessProfile extends Tables<'business_profiles'> { user: Tables<'users'>; venues?: Tables<'venues'>[]; statistics?: BusinessStatistics; campaigns?: CampaignSummary[]; roi_metrics?: ROIMetrics;
} export interface BusinessStatistics { total_campaigns: number; active_campaigns: number; completed_campaigns: number; total_spent: number; total_roi: number; avg_campaign_performance: number; creator_relationships: number; repeat_collaborations: number; avg_campaign_duration: number; success_rate: number;
} export interface CampaignSummary { id: string; title: string; status: string; budget: number; spent: number; roi: number; creator_name?: string; start_date: string; end_date?: string; performance_score: number;
} export interface ROIMetrics { overall_roi: number; roi_by_category: Record<string, number>; roi_trend: Array<{ month: string; roi: number }>; top_performing_campaigns: CampaignSummary[]; cost_per_engagement: number; conversion_rate: number; customer_acquisition_cost: number; lifetime_value_ratio: number;
} export interface CampaignAnalytics { campaign_id: string; impressions: number; engagements: number; clicks: number; conversions: number; reach: number; engagement_rate: number; click_through_rate: number; conversion_rate: number; cost_per_click: number; cost_per_conversion: number; roi: number; audience_demographics: { age_groups: Record<string, number>; gender_split: Record<string, number>; locations: Record<string, number>; interests: string[]; };
} export interface BusinessInsights { content_performance: { top_content_types: string[]; best_posting_times: string[]; optimal_campaign_duration: number; seasonal_trends: Array<{ season: string; performance: number }>; }; creator_insights: { most_effective_creators: Array<{ creator_id: string; name: string; avg_roi: number }>; creator_types_performance: Record<string, number>; collaboration_patterns: string[]; }; budget_optimization: { recommended_budget_allocation: Record<string, number>; cost_saving_opportunities: string[]; roi_improvement_suggestions: string[]; }; market_opportunities: { trending_categories: string[]; underutilized_platforms: string[]; competitor_gaps: string[]; };
} export interface BusinessSearchFilters { search?: string; industry?: string; company_size?: string; location?: string; verified_only?: boolean; has_active_campaigns?: boolean; budget_range?: [number, number]; sort_by?: 'name' | 'size' | 'spending' | 'performance' | 'recent'; sort_order?: 'asc' | 'desc';
} class EnhancedBusinessService { // Advanced business search and filtering async searchBusinesses( filters: BusinessSearchFilters = {}, limit: number = 20, offset: number = 0 ): Promise<BusinessProfile[]> { try { let query = supabase .from('business_profiles') .select(` *, user:users(*), venues(*) `); // Apply filters if (filters.search) { query = query.or( `company_name.ilike.%${filters.search}%,description.ilike.%${filters.search}%,industry.ilike.%${filters.search}%` ); } if (filters.industry) { query = query.eq('industry', filters.industry); } if (filters.company_size) { query = query.eq('company_size', filters.company_size); } if (filters.location) { query = query.ilike('address', `%${filters.location}%`); } if (filters.verified_only) { query = query.eq('is_verified_business', true); } // Apply sorting const sortColumn = this.getSortColumn(filters.sort_by); const ascending = filters.sort_order === 'asc'; query = query.order(sortColumn, { ascending }); const { data, error } = await query .range(offset, offset + limit - 1); if (error) { throw error; } // Enhance with statistics const enhancedData = await Promise.all( (data || []).map(async (business) => { const statistics = await this.getBusinessStatistics(business.id); return { ...business, statistics }; }) ); return enhancedData; } catch (error) { console.error('Failed to search businesses:', error); return []; } } // Get comprehensive business statistics async getBusinessStatistics(businessId: string): Promise<BusinessStatistics> { try { // Get campaigns data const campaigns = await collaborationService.getBusinessCollaborations(businessId); const activeCampaigns = campaigns.filter(c => ['accepted', 'in_progress'].includes(c.status || '')); const completedCampaigns = campaigns.filter(c => c.status === 'completed'); // Get payment data const businessProfile = await this.getBusinessById(businessId); const payments = businessProfile ? await paymentsService.getUserPayments(businessProfile.user_id) : []; const totalSpent = payments .filter(p => p.status === 'approved') .reduce((sum, p) => sum + p.amount, 0); // Calculate ROI metrics const totalROI = await this.calculateOverallROI(businessId); // Get creator relationships const uniqueCreators = new Set(campaigns.map(c => c.creator_id).filter(Boolean)); const repeatCollaborations = await this.countRepeatCollaborations(businessId); // Calculate success rate const successRate = campaigns.length > 0 ? (completedCampaigns.length / campaigns.length) * 100 : 0; // Calculate average campaign duration const avgDuration = await this.calculateAverageCampaignDuration(completedCampaigns); return { total_campaigns: campaigns.length, active_campaigns: activeCampaigns.length, completed_campaigns: completedCampaigns.length, total_spent: totalSpent, total_roi: totalROI, avg_campaign_performance: await this.calculateAveragePerformance(businessId), creator_relationships: uniqueCreators.size, repeat_collaborations: repeatCollaborations, avg_campaign_duration: avgDuration, success_rate: successRate }; } catch (error) { console.error('Failed to get business statistics:', error); return { total_campaigns: 0, active_campaigns: 0, completed_campaigns: 0, total_spent: 0, total_roi: 0, avg_campaign_performance: 0, creator_relationships: 0, repeat_collaborations: 0, avg_campaign_duration: 0, success_rate: 0 }; } } // Get ROI metrics and analysis async getROIMetrics(businessId: string): Promise<ROIMetrics> { try { const campaigns = await collaborationService.getBusinessCollaborations(businessId); const completedCampaigns = campaigns.filter(c => c.status === 'completed'); // Calculate overall ROI const overallROI = await this.calculateOverallROI(businessId); // ROI by category const roiByCategory = await this.calculateROIByCategory(completedCampaigns); // ROI trend over time const roiTrend = await this.calculateROITrend(businessId, 12); // Last 12 months // Top performing campaigns const topCampaigns = await this.getTopPerformingCampaigns(businessId, 5); // Calculate advanced metrics const costPerEngagement = await this.calculateCostPerEngagement(businessId); const conversionRate = await this.calculateConversionRate(businessId); const cac = await this.calculateCustomerAcquisitionCost(businessId); const ltvRatio = await this.calculateLifetimeValueRatio(businessId); return { overall_roi: overallROI, roi_by_category: roiByCategory, roi_trend: roiTrend, top_performing_campaigns: topCampaigns, cost_per_engagement: costPerEngagement, conversion_rate: conversionRate, customer_acquisition_cost: cac, lifetime_value_ratio: ltvRatio }; } catch (error) { console.error('Failed to get ROI metrics:', error); return { overall_roi: 0, roi_by_category: {}, roi_trend: [], top_performing_campaigns: [], cost_per_engagement: 0, conversion_rate: 0, customer_acquisition_cost: 0, lifetime_value_ratio: 0 }; } } // Get detailed campaign analytics async getCampaignAnalytics(campaignId: string): Promise<CampaignAnalytics> { try { // In production, this would integrate with social media APIs and analytics platforms // For now, return mock data with realistic metrics const campaign = await collaborationService.getCollaboration(campaignId); if (!campaign) { throw new Error('Campaign not found'); } // Mock analytics data - in production, integrate with actual platforms return { campaign_id: campaignId, impressions: Math.floor(Math.random() * 100000) + 50000, engagements: Math.floor(Math.random() * 5000) + 2000, clicks: Math.floor(Math.random() * 1000) + 500, conversions: Math.floor(Math.random() * 100) + 25, reach: Math.floor(Math.random() * 80000) + 40000, engagement_rate: Math.random() * 5 + 2, click_through_rate: Math.random() * 2 + 0.5, conversion_rate: Math.random() * 5 + 1, cost_per_click: Math.random() * 2 + 0.5, cost_per_conversion: Math.random() * 20 + 10, roi: Math.random() * 3 + 1.5, audience_demographics: { age_groups: { '18-24': 25, '25-34': 35, '35-44': 25, '45-54': 15 }, gender_split: { 'Female': 60, 'Male': 38, 'Other': 2 }, locations: { 'Buenos Aires': 45, 'CÃ³rdoba': 20, 'Rosario': 15, 'Other': 20 }, interests: ['Beauty', 'Fashion', 'Lifestyle', 'Food'] } }; } catch (error) { console.error('Failed to get campaign analytics:', error); throw error; } } // Get business insights and recommendations async getBusinessInsights(businessId: string): Promise<BusinessInsights> { try { const campaigns = await collaborationService.getBusinessCollaborations(businessId); const completedCampaigns = campaigns.filter(c => c.status === 'completed'); // Analyze content performance const contentPerformance = await this.analyzeContentPerformance(completedCampaigns); // Analyze creator effectiveness const creatorInsights = await this.analyzeCreatorEffectiveness(businessId); // Budget optimization analysis const budgetOptimization = await this.analyzeBudgetOptimization(businessId); // Market opportunities const marketOpportunities = await this.identifyMarketOpportunities(businessId); return { content_performance: contentPerformance, creator_insights: creatorInsights, budget_optimization: budgetOptimization, market_opportunities: marketOpportunities }; } catch (error) { console.error('Failed to get business insights:', error); return { content_performance: { top_content_types: [], best_posting_times: [], optimal_campaign_duration: 0, seasonal_trends: [] }, creator_insights: { most_effective_creators: [], creator_types_performance: {}, collaboration_patterns: [] }, budget_optimization: { recommended_budget_allocation: {}, cost_saving_opportunities: [], roi_improvement_suggestions: [] }, market_opportunities: { trending_categories: [], underutilized_platforms: [], competitor_gaps: [] } }; } } // Create comprehensive campaign with budget planning async createCampaignWithBudget( businessId: string, campaignData: { title: string; description: string; category: string; target_audience: any; budget: number; duration_days: number; objectives: string[]; kpis: string[]; preferred_creator_types: string[]; } ): Promise<{ campaign: any; budget_breakdown: any; recommended_creators: any[]; timeline: any[]; }> { try { // Create the collaboration/campaign const campaign = await collaborationService.createCollaboration({ business_id: businessId, title: campaignData.title, description: campaignData.description, collaboration_type: campaignData.category, compensation_amount: campaignData.budget, status: 'proposed', requirements: { target_audience: campaignData.target_audience, objectives: campaignData.objectives, kpis: campaignData.kpis, duration_days: campaignData.duration_days } }); // Calculate budget breakdown const budgetBreakdown = this.calculateBudgetBreakdown(campaignData.budget); // Get creator recommendations const recommendedCreators = await enhancedCreatorsService.getRecommendations( businessId, { category: campaignData.category, budget_range: [campaignData.budget * 0.7, campaignData.budget * 1.3], target_audience: campaignData.target_audience.demographics || [], campaign_goals: campaignData.objectives, preferred_platforms: ['instagram', 'tiktok'] // default }, 10 ); // Create campaign timeline const timeline = this.createCampaignTimeline(campaignData.duration_days); // Log campaign creation await auditService.logUserAction( (await this.getBusinessById(businessId))?.user_id || '', 'unknown', 'Created campaign with budget planning', 'campaign', campaign.id, { title: campaignData.title, budget: campaignData.budget, category: campaignData.category } ); return { campaign, budget_breakdown: budgetBreakdown, recommended_creators: recommendedCreators, timeline }; } catch (error) { console.error('Failed to create campaign with budget:', error); throw error; } } // Track campaign performance in real-time async trackCampaignPerformance( campaignId: string ): Promise<{ current_metrics: any; performance_vs_goals: any; recommendations: string[]; budget_utilization: number; }> { try { // Get current campaign analytics const analytics = await this.getCampaignAnalytics(campaignId); // Get campaign details and goals const campaign = await collaborationService.getCollaboration(campaignId); if (!campaign) { throw new Error('Campaign not found'); } // Compare performance vs goals const performanceVsGoals = await this.comparePerformanceVsGoals(campaign, analytics); // Generate recommendations const recommendations = await this.generatePerformanceRecommendations(analytics, campaign); // Calculate budget utilization const budgetUtilization = await this.calculateBudgetUtilization(campaignId); return { current_metrics: { impressions: analytics.impressions, engagement_rate: analytics.engagement_rate, conversion_rate: analytics.conversion_rate, roi: analytics.roi, cost_per_conversion: analytics.cost_per_conversion }, performance_vs_goals: performanceVsGoals, recommendations, budget_utilization }; } catch (error) { console.error('Failed to track campaign performance:', error); throw error; } } // Business dashboard with key metrics async getBusinessDashboard(businessId: string): Promise<{ overview: any; active_campaigns: CampaignSummary[]; recent_performance: any; budget_status: any; upcoming_deadlines: any[]; recommendations: string[]; }> { try { // Get overview statistics const statistics = await this.getBusinessStatistics(businessId); // Get active campaigns const activeCampaigns = await this.getActiveCampaignsSummary(businessId); // Get recent performance trends const recentPerformance = await this.getRecentPerformanceTrends(businessId); // Get budget status const budgetStatus = await this.getBudgetStatus(businessId); // Get upcoming deadlines const upcomingDeadlines = await this.getUpcomingDeadlines(businessId); // Generate dashboard recommendations const recommendations = await this.generateDashboardRecommendations(businessId); return { overview: { total_campaigns: statistics.total_campaigns, active_campaigns: statistics.active_campaigns, total_spent: statistics.total_spent, avg_roi: statistics.total_roi, success_rate: statistics.success_rate }, active_campaigns: activeCampaigns, recent_performance: recentPerformance, budget_status: budgetStatus, upcoming_deadlines: upcomingDeadlines, recommendations }; } catch (error) { console.error('Failed to get business dashboard:', error); throw error; } } // Private helper methods private async getBusinessById(businessId: string): Promise<BusinessProfile | null> { try { const { data, error } = await supabase .from('business_profiles') .select(` *, user:users(*), venues(*) `) .eq('id', businessId) .single(); if (error) { if (error.code === 'PGRST116') { return null; } throw error; } return data; } catch (error) { console.error('Failed to get business by ID:', error); return null; } } private getSortColumn(sortBy?: string): string { switch (sortBy) { case 'name': return 'company_name'; case 'size': return 'company_size'; case 'recent': return 'updated_at'; default: return 'created_at'; } } private async calculateOverallROI(businessId: string): Promise<number> { // Mock ROI calculation - in production, integrate with analytics platforms return Math.random() * 2 + 1.5; // 1.5x to 3.5x ROI } private async calculateAveragePerformance(businessId: string): Promise<number> { // Mock performance score - in production, calculate from real metrics return Math.random() * 40 + 60; // 60-100 performance score } private async countRepeatCollaborations(businessId: string): Promise<number> { try { const collaborations = await collaborationService.getBusinessCollaborations(businessId); const creatorCollaborations: Record<string, number> = {}; collaborations.forEach(collab => { if (collab.creator_id) { creatorCollaborations[collab.creator_id] = (creatorCollaborations[collab.creator_id] || 0) + 1; } }); return Object.values(creatorCollaborations).filter(count => count > 1).length; } catch (error) { return 0; } } private async calculateAverageCampaignDuration(campaigns: any[]): Promise<number> { if (campaigns.length === 0) return 0; const durations = campaigns .filter(c => c.completed_at && c.created_at) .map(c => { const start = new Date(c.created_at); const end = new Date(c.completed_at); return (end.getTime() - start.getTime()) / (1000 * 60 * 60 * 24); // days }); return durations.length > 0 ? durations.reduce((sum, d) => sum + d, 0) / durations.length : 0; } private async calculateROIByCategory(campaigns: any[]): Promise<Record<string, number>> { const categoryROI: Record<string, number> = {}; campaigns.forEach(campaign => { const category = campaign.collaboration_type || 'general'; // Mock ROI calculation categoryROI[category] = Math.random() * 2 + 1.2; }); return categoryROI; } private async calculateROITrend(businessId: string, months: number): Promise<Array<{ month: string; roi: number }>> { const trend = []; const now = new Date(); for (let i = months - 1; i >= 0; i--) { const date = new Date(now.getFullYear(), now.getMonth() - i, 1); const month = date.toISOString().substring(0, 7); // Mock ROI data - in production, calculate from actual campaigns trend.push({ month, roi: Math.random() * 2 + 1.5 }); } return trend; } private async getTopPerformingCampaigns(businessId: string, limit: number): Promise<CampaignSummary[]> { try { const campaigns = await collaborationService.getBusinessCollaborations(businessId); // Mock performance scoring and return top campaigns return campaigns .filter(c => c.status === 'completed') .map(c => ({ id: c.id, title: c.title, status: c.status || '', budget: c.compensation_amount || 0, spent: (c.compensation_amount || 0) * 0.9, // 90% utilization roi: Math.random() * 3 + 1, start_date: c.created_at || '', end_date: c.completed_at, performance_score: Math.random() * 40 + 60 })) .sort((a, b) => b.performance_score - a.performance_score) .slice(0, limit); } catch (error) { return []; } } private async calculateCostPerEngagement(businessId: string): Promise<number> { // Mock calculation - in production, integrate with analytics return Math.random() * 2 + 0.5; } private async calculateConversionRate(businessId: string): Promise<number> { // Mock conversion rate return Math.random() * 5 + 2; } private async calculateCustomerAcquisitionCost(businessId: string): Promise<number> { // Mock CAC return Math.random() * 50 + 25; } private async calculateLifetimeValueRatio(businessId: string): Promise<number> { // Mock LTV ratio return Math.random() * 5 + 2; } // Additional helper methods for insights and analytics private async analyzeContentPerformance(campaigns: any[]): Promise<any> { return { top_content_types: ['Video', 'Stories', 'Posts', 'Reels'], best_posting_times: ['9:00 AM', '1:00 PM', '7:00 PM'], optimal_campaign_duration: 14, // days seasonal_trends: [ { season: 'Q1', performance: 85 }, { season: 'Q2', performance: 92 }, { season: 'Q3', performance: 78 }, { season: 'Q4', performance: 95 } ] }; } private async analyzeCreatorEffectiveness(businessId: string): Promise<any> { return { most_effective_creators: [ { creator_id: '1', name: 'Top Creator 1', avg_roi: 3.2 }, { creator_id: '2', name: 'Top Creator 2', avg_roi: 2.8 } ], creator_types_performance: { 'Micro-influencers': 2.8, 'Macro-influencers': 2.3, 'Nano-influencers': 3.1 }, collaboration_patterns: [ 'Long-term partnerships perform 35% better', 'Multi-platform campaigns increase reach by 60%' ] }; } private async analyzeBudgetOptimization(businessId: string): Promise<any> { return { recommended_budget_allocation: { 'Content Creation': 40, 'Paid Promotion': 35, 'Creator Fees': 20, 'Platform Tools': 5 }, cost_saving_opportunities: [ 'Switch to performance-based pricing for 15% savings', 'Bundle campaigns for volume discounts' ], roi_improvement_suggestions: [ 'Focus on micro-influencers for better engagement', 'Implement A/B testing for creative content' ] }; } private async identifyMarketOpportunities(businessId: string): Promise<any> { return { trending_categories: ['Sustainability', 'Health & Wellness', 'Tech Reviews'], underutilized_platforms: ['YouTube Shorts', 'LinkedIn', 'Pinterest'], competitor_gaps: ['Lack of video content', 'Limited influencer diversity'] }; } private calculateBudgetBreakdown(totalBudget: number): any { return { creator_fees: totalBudget * 0.60, content_production: totalBudget * 0.25, platform_promotion: totalBudget * 0.10, management_fee: totalBudget * 0.05 }; } private createCampaignTimeline(durationDays: number): any[] { const timeline = []; const now = new Date(); // Planning phase (20% of duration) timeline.push({ phase: 'Planning & Creator Selection', start_date: now.toISOString(), duration_days: Math.ceil(durationDays * 0.2), tasks: ['Brief creation', 'Creator outreach', 'Contract negotiation'] }); // Content creation phase (50% of duration) timeline.push({ phase: 'Content Creation', start_date: new Date(now.getTime() + durationDays * 0.2 * 24 * 60 * 60 * 1000).toISOString(), duration_days: Math.ceil(durationDays * 0.5), tasks: ['Content planning', 'Production', 'Review & approval'] }); // Execution phase (30% of duration) timeline.push({ phase: 'Campaign Execution', start_date: new Date(now.getTime() + durationDays * 0.7 * 24 * 60 * 60 * 1000).toISOString(), duration_days: Math.ceil(durationDays * 0.3), tasks: ['Content publishing', 'Performance monitoring', 'Optimization'] }); return timeline; } private async comparePerformanceVsGoals(campaign: any, analytics: CampaignAnalytics): Promise<any> { // Mock comparison - in production, compare with campaign goals return { engagement_rate: { goal: 4.0, actual: analytics.engagement_rate, performance: analytics.engagement_rate / 4.0 }, conversion_rate: { goal: 2.5, actual: analytics.conversion_rate, performance: analytics.conversion_rate / 2.5 }, roi: { goal: 2.0, actual: analytics.roi, performance: analytics.roi / 2.0 } }; } private async generatePerformanceRecommendations(analytics: CampaignAnalytics, campaign: any): Promise<string[]> { const recommendations = []; if (analytics.engagement_rate < 3) { recommendations.push('Consider optimizing content format for better engagement'); } if (analytics.conversion_rate < 2) { recommendations.push('Review call-to-action placement and messaging'); } if (analytics.cost_per_conversion > 15) { recommendations.push('Optimize targeting to reduce acquisition costs'); } return recommendations; } private async calculateBudgetUtilization(campaignId: string): Promise<number> { // Mock budget utilization calculation return Math.random() * 30 + 70; // 70-100% utilization } private async getActiveCampaignsSummary(businessId: string): Promise<CampaignSummary[]> { const campaigns = await collaborationService.getBusinessCollaborations(businessId); const activeCampaigns = campaigns.filter(c => ['accepted', 'in_progress'].includes(c.status || '')); return activeCampaigns.map(c => ({ id: c.id, title: c.title, status: c.status || '', budget: c.compensation_amount || 0, spent: (c.compensation_amount || 0) * 0.6, // 60% spent on average roi: Math.random() * 2 + 1, start_date: c.created_at || '', performance_score: Math.random() * 40 + 60 })); } private async getRecentPerformanceTrends(businessId: string): Promise<any> { // Mock recent performance trends return { engagement_trend: 'up', conversion_trend: 'stable', roi_trend: 'up', cost_trend: 'down' }; } private async getBudgetStatus(businessId: string): Promise<any> { // Mock budget status return { monthly_budget: 50000, spent_this_month: 32000, utilization_rate: 64, remaining_budget: 18000, projected_overspend: false }; } private async getUpcomingDeadlines(businessId: string): Promise<any[]> { // Mock upcoming deadlines return [ { campaign_id: '1', title: 'Summer Campaign', deadline: new Date(Date.now() + 3 * 24 * 60 * 60 * 1000).toISOString(), type: 'Content Delivery', priority: 'high' }, { campaign_id: '2', title: 'Product Launch', deadline: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString(), type: 'Campaign End', priority: 'medium' } ]; } private async generateDashboardRecommendations(businessId: string): Promise<string[]> { return [ 'Consider increasing budget for high-performing campaigns', 'Explore partnerships with micro-influencers for better ROI', 'Implement automated performance monitoring for faster optimization' ]; }
} export const enhancedBusinessService = new EnhancedBusinessService();
export default enhancedBusinessService;