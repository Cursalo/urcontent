// File Upload Service
// Comprehensive file handling with CDN integration and security import { supabase } from '@/integrations/supabase/client';
import { Tables, TablesInsert } from '@/integrations/supabase/types';
import { rateLimitService } from './rateLimitService';
import { auditService } from './auditService';
import { authService } from './authService'; export type FileType = 'image' | 'video' | 'document' | 'audio' | 'other';
export type FileCategory = 'profile_picture' | 'portfolio' | 'collaboration' | 'document' | 'media';
export type FileStatus = 'uploading' | 'processing' | 'ready' | 'failed' | 'deleted'; export interface FileUploadOptions { category: FileCategory; userId: string; maxSize?: number; // in bytes allowedTypes?: string[]; compress?: boolean; generateThumbnail?: boolean; metadata?: Record<string, any>;
} export interface UploadedFile { id: string; user_id: string; filename: string; original_filename: string; file_type: FileType; category: FileCategory; mime_type: string; file_size: number; url: string; thumbnail_url?: string; cdn_url?: string; status: FileStatus; metadata?: Record<string, any>; upload_progress?: number; created_at: string; updated_at: string;
} export interface FileFilters { user_id?: string; category?: FileCategory; file_type?: FileType; status?: FileStatus; date_from?: string; date_to?: string; search_term?: string;
} export interface FileUploadProgress { fileId: string; progress: number; status: 'uploading' | 'processing' | 'complete' | 'error'; bytesUploaded: number; totalBytes: number; error?: string;
} export interface FileProcessingResult { success: boolean; file?: UploadedFile; thumbnailUrl?: string; compressedUrl?: string; error?: string;
} class FileUploadService { private readonly MAX_FILE_SIZE = { image: 10 * 1024 * 1024, // 10MB video: 500 * 1024 * 1024, // 500MB document: 50 * 1024 * 1024, // 50MB audio: 100 * 1024 * 1024, // 100MB other: 25 * 1024 * 1024 // 25MB }; private readonly ALLOWED_TYPES = { image: ['image/jpeg', 'image/png', 'image/gif', 'image/webp'], video: ['video/mp4', 'video/webm', 'video/mov', 'video/avi'], document: ['application/pdf', 'application/msword', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'], audio: ['audio/mp3', 'audio/wav', 'audio/ogg', 'audio/m4a'] }; private uploadProgressCallbacks = new Map<string, (progress: FileUploadProgress) => void>(); // Upload single file async uploadFile( file: File, options: FileUploadOptions, onProgress?: (progress: FileUploadProgress) => void ): Promise<UploadedFile> { try { // Rate limiting check const isAllowed = await rateLimitService.checkAPIRateLimit( options.userId, 'upload' ); if (!isAllowed) { throw new Error('Demasiados archivos subidos. Intenta nuevamente en una hora.'); } // Validate file const validation = this.validateFile(file, options); if (!validation.isValid) { throw new Error(validation.error!); } // Generate unique filename const fileId = this.generateFileId(); const filename = this.generateFilename(file.name, fileId); const fileType = this.getFileType(file.type); // Create file record const fileRecord: TablesInsert<'files'> = { id: fileId, user_id: options.userId, filename, original_filename: file.name, file_type: fileType, category: options.category, mime_type: file.type, file_size: file.size, status: 'uploading', metadata: options.metadata || {}, url: '' // Will be updated after upload }; const { data: createdFile, error: createError } = await supabase .from('files') .insert(fileRecord) .select() .single(); if (createError) { throw new Error(`Error creating file record: ${createError.message}`); } // Set up progress callback if (onProgress) { this.uploadProgressCallbacks.set(fileId, onProgress); } // Upload to Supabase Storage const uploadResult = await this.uploadToStorage(file, filename, fileId, onProgress); if (!uploadResult.success) { await this.updateFileStatus(fileId, 'failed', uploadResult.error); throw new Error(uploadResult.error || 'Upload failed'); } // Update file record with URL const updatedFile = await this.updateFileRecord(fileId, { url: uploadResult.url!, status: 'processing' }); // Process file (compression, thumbnails, etc.) const processingResult = await this.processFile(updatedFile, options); if (processingResult.success && processingResult.file) { // Log successful upload await auditService.logUserAction( options.userId, (await authService.getCurrentUser())?.user?.email || 'unknown', 'File uploaded', 'file', fileId, { filename: file.name, category: options.category, file_size: file.size, file_type: fileType } ); return processingResult.file; } else { throw new Error(processingResult.error || 'File processing failed'); } } catch (error: any) { console.error('File upload error:', error); // Log upload error await auditService.logUserAction( options.userId, (await authService.getCurrentUser())?.user?.email || 'unknown', 'File upload failed', 'file', undefined, { filename: file.name, error: error.message, file_size: file.size }, false ); throw error; } } // Upload multiple files async uploadFiles( files: FileList | File[], options: FileUploadOptions, onProgress?: (fileId: string, progress: FileUploadProgress) => void ): Promise<UploadedFile[]> { const fileArray = Array.from(files); const uploadPromises = fileArray.map(file => this.uploadFile(file, options, onProgress ? (progress) => onProgress(progress.fileId, progress) : undefined) ); // Upload files concurrently but with a limit const results = await this.batchProcess(uploadPromises, 3); // Max 3 concurrent uploads return results.filter(result => result !== null) as UploadedFile[]; } // Get uploaded files with filtering async getFiles( filters: FileFilters = {}, limit: number = 50, offset: number = 0 ): Promise<UploadedFile[]> { try { let query = supabase .from('files') .select('*'); // Apply filters if (filters.user_id) { query = query.eq('user_id', filters.user_id); } if (filters.category) { query = query.eq('category', filters.category); } if (filters.file_type) { query = query.eq('file_type', filters.file_type); } if (filters.status) { query = query.eq('status', filters.status); } if (filters.date_from) { query = query.gte('created_at', filters.date_from); } if (filters.date_to) { query = query.lte('created_at', filters.date_to); } if (filters.search_term) { query = query.or( `filename.ilike.%${filters.search_term}%,original_filename.ilike.%${filters.search_term}%` ); } const { data, error } = await query .order('created_at', { ascending: false }) .range(offset, offset + limit - 1); if (error) { throw error; } return data || []; } catch (error) { console.error('Error fetching files:', error); return []; } } // Get single file by ID async getFile(fileId: string): Promise<UploadedFile | null> { try { const { data, error } = await supabase .from('files') .select('*') .eq('id', fileId) .single(); if (error) { if (error.code === 'PGRST116') { return null; } throw error; } return data; } catch (error) { console.error('Error fetching file:', error); return null; } } // Delete file async deleteFile(fileId: string, userId: string): Promise<void> { try { const file = await this.getFile(fileId); if (!file) { throw new Error('File not found'); } if (file.user_id !== userId) { throw new Error('Unauthorized to delete this file'); } // Delete from storage const { error: storageError } = await supabase.storage .from('files') .remove([file.filename]); if (storageError) { console.warn('Storage deletion error:', storageError); } // Delete thumbnails if they exist if (file.thumbnail_url) { const thumbnailPath = this.extractPathFromUrl(file.thumbnail_url); if (thumbnailPath) { await supabase.storage .from('files') .remove([thumbnailPath]); } } // Update file status to deleted (soft delete) await this.updateFileRecord(fileId, { status: 'deleted', deleted_at: new Date().toISOString() }); // Log deletion await auditService.logUserAction( userId, (await authService.getCurrentUser())?.user?.email || 'unknown', 'File deleted', 'file', fileId, { filename: file.original_filename, category: file.category, file_size: file.file_size } ); console.log(`‚úÖ File ${fileId} deleted successfully`); } catch (error) { console.error('Error deleting file:', error); throw error; } } // Generate signed URL for private files async generateSignedUrl(fileId: string, expiresIn: number = 3600): Promise<string> { try { const file = await this.getFile(fileId); if (!file) { throw new Error('File not found'); } const { data, error } = await supabase.storage .from('files') .createSignedUrl(file.filename, expiresIn); if (error) { throw error; } return data.signedUrl; } catch (error) { console.error('Error generating signed URL:', error); throw error; } } // Get file usage statistics async getFileStats(userId?: string): Promise<{ total_files: number; total_size: number; files_by_type: Record<FileType, number>; files_by_category: Record<FileCategory, number>; storage_used: string; storage_limit: string; }> { try { const filters: FileFilters = { status: 'ready' }; if (userId) { filters.user_id = userId; } const files = await this.getFiles(filters, 10000); const stats = { total_files: files.length, total_size: files.reduce((sum, file) => sum + file.file_size, 0), files_by_type: {} as Record<FileType, number>, files_by_category: {} as Record<FileCategory, number>, storage_used: '', storage_limit: '10GB' // Mock limit }; // Count by type and category files.forEach(file => { stats.files_by_type[file.file_type] = (stats.files_by_type[file.file_type] || 0) + 1; stats.files_by_category[file.category] = (stats.files_by_category[file.category] || 0) + 1; }); stats.storage_used = this.formatFileSize(stats.total_size); return stats; } catch (error) { console.error('Error getting file stats:', error); return { total_files: 0, total_size: 0, files_by_type: {} as Record<FileType, number>, files_by_category: {} as Record<FileCategory, number>, storage_used: '0 MB', storage_limit: '10 GB' }; } } // Private helper methods private validateFile(file: File, options: FileUploadOptions): { isValid: boolean; error?: string } { // Check file size const maxSize = options.maxSize || this.MAX_FILE_SIZE.other; if (file.size > maxSize) { return { isValid: false, error: `El archivo es demasiado grande. Tama√±o m√°ximo: ${this.formatFileSize(maxSize)}` }; } // Check file type const fileType = this.getFileType(file.type); const allowedTypes = options.allowedTypes || this.ALLOWED_TYPES[fileType] || []; if (allowedTypes.length > 0 && !allowedTypes.includes(file.type)) { return { isValid: false, error: `Tipo de archivo no permitido. Tipos permitidos: ${allowedTypes.join(', ')}` }; } // Check filename if (file.name.length > 255) { return { isValid: false, error: 'El nombre del archivo es demasiado largo.' }; } return { isValid: true }; } private getFileType(mimeType: string): FileType { if (mimeType.startsWith('image/')) return 'image'; if (mimeType.startsWith('video/')) return 'video'; if (mimeType.startsWith('audio/')) return 'audio'; if (mimeType.includes('pdf') || mimeType.includes('document') || mimeType.includes('text')) return 'document'; return 'other'; } private generateFileId(): string { return `file_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`; } private generateFilename(originalName: string, fileId: string): string { const extension = originalName.split('.').pop() || ''; const timestamp = Date.now(); return `${fileId}_${timestamp}.${extension}`; } private async uploadToStorage( file: File, filename: string, fileId: string, onProgress?: (progress: FileUploadProgress) => void ): Promise<{ success: boolean; url?: string; error?: string }> { try { // Update progress if (onProgress) { onProgress({ fileId, progress: 0, status: 'uploading', bytesUploaded: 0, totalBytes: file.size }); } const { data, error } = await supabase.storage .from('files') .upload(filename, file, { cacheControl: '3600', upsert: false }); if (error) { return { success: false, error: error.message }; } // Get public URL const { data: urlData } = supabase.storage .from('files') .getPublicUrl(filename); // Update progress if (onProgress) { onProgress({ fileId, progress: 100, status: 'complete', bytesUploaded: file.size, totalBytes: file.size }); } return { success: true, url: urlData.publicUrl }; } catch (error: any) { if (onProgress) { onProgress({ fileId, progress: 0, status: 'error', bytesUploaded: 0, totalBytes: file.size, error: error.message }); } return { success: false, error: error.message }; } } private async processFile( file: UploadedFile, options: FileUploadOptions ): Promise<FileProcessingResult> { try { let thumbnailUrl: string | undefined; let compressedUrl: string | undefined; // Generate thumbnail for images and videos if ((file.file_type === 'image' || file.file_type === 'video') && options.generateThumbnail) { thumbnailUrl = await this.generateThumbnail(file); } // Compress images if requested if (file.file_type === 'image' && options.compress) { compressedUrl = await this.compressImage(file); } // Update file record with processing results const updatedFile = await this.updateFileRecord(file.id, { status: 'ready', thumbnail_url: thumbnailUrl, cdn_url: compressedUrl || file.url, processed_at: new Date().toISOString() }); return { success: true, file: updatedFile, thumbnailUrl, compressedUrl }; } catch (error: any) { await this.updateFileStatus(file.id, 'failed', error.message); return { success: false, error: error.message }; } } private async generateThumbnail(file: UploadedFile): Promise<string | undefined> { try { // In production, this would use an image processing service // For now, return a placeholder or the original URL console.log(`üì∏ Generating thumbnail for ${file.filename}`); // Mock thumbnail generation return file.url; // In production, return actual thumbnail URL } catch (error) { console.error('Thumbnail generation error:', error); return undefined; } } private async compressImage(file: UploadedFile): Promise<string | undefined> { try { // In production, this would use an image compression service console.log(`üóúÔ∏è Compressing image ${file.filename}`); // Mock compression return file.url; // In production, return compressed image URL } catch (error) { console.error('Image compression error:', error); return undefined; } } private async updateFileRecord( fileId: string, updates: Partial<UploadedFile> ): Promise<UploadedFile> { const { data, error } = await supabase .from('files') .update({ ...updates, updated_at: new Date().toISOString() }) .eq('id', fileId) .select() .single(); if (error) { throw new Error(`Error updating file record: ${error.message}`); } return data; } private async updateFileStatus( fileId: string, status: FileStatus, errorMessage?: string ): Promise<void> { const updates: any = { status }; if (errorMessage) { updates.error_message = errorMessage; } if (status === 'failed') { updates.failed_at = new Date().toISOString(); } await supabase .from('files') .update(updates) .eq('id', fileId); } private extractPathFromUrl(url: string): string | null { try { const urlParts = url.split('/'); return urlParts[urlParts.length - 1]; } catch { return null; } } private formatFileSize(bytes: number): string { if (bytes === 0) return '0 Bytes'; const k = 1024; const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB']; const i = Math.floor(Math.log(bytes) / Math.log(k)); return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i]; } private async batchProcess<T>( promises: Promise<T>[], batchSize: number ): Promise<(T | null)[]> { const results: (T | null)[] = []; for (let i = 0; i < promises.length; i += batchSize) { const batch = promises.slice(i, i + batchSize); const batchResults = await Promise.allSettled(batch); batchResults.forEach(result => { if (result.status === 'fulfilled') { results.push(result.value); } else { console.error('Batch processing error:', result.reason); results.push(null); } }); } return results; }
} export const fileUploadService = new FileUploadService();
export default fileUploadService;