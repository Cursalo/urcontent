import { supabase } from '@/integrations/supabase/client';
import { Tables, TablesInsert, TablesUpdate } from '@/integrations/supabase/types'; export type Credit = Tables<'credits'> & { user: Tables<'users'>;
}; export type CreditTransaction = { id: string; user_id: string; transaction_type: 'earned' | 'spent' | 'refunded' | 'expired' | 'bonus'; amount: number; balance_after: number; reference_id?: string; reference_type?: string; description?: string; expires_at?: string; created_at: string;
}; export type CreditFilters = { user_id?: string; transaction_type?: string; reference_type?: string; date_from?: string; date_to?: string; include_expired?: boolean;
}; export type CreditBalance = { user_id: string; total_balance: number; available_balance: number; // Excluding expired credits expired_credits: number; pending_credits: number; // Credits that haven't been processed yet lifetime_earned: number; lifetime_spent: number;
}; export type MembershipCredits = { basic: number; premium: number; vip: number;
}; class CreditsService { // Get user's current credit balance async getUserCreditBalance(userId: string): Promise<number> { try { // Use the database function for accurate balance calculation const { data, error } = await supabase .rpc('calculate_user_credit_balance', { target_user_id: userId }); if (error) { console.error('Error calculating credit balance:', error); throw error; } return data || 0; } catch (error) { console.error('Error fetching user credit balance:', error); throw error; } } // Get detailed credit balance information async getDetailedCreditBalance(userId: string): Promise<CreditBalance> { const { data: credits, error } = await supabase .from('credits') .select('*') .eq('user_id', userId) .order('created_at', { ascending: false }); if (error) { console.error('Error fetching credit transactions:', error); throw error; } const now = new Date(); const transactions = credits || []; // Calculate various balances const totalBalance = await this.getUserCreditBalance(userId); const expiredCredits = transactions .filter(c => c.expires_at && new Date(c.expires_at) < now) .reduce((sum, c) => sum + (c.amount > 0 ? c.amount : 0), 0); const availableBalance = totalBalance - expiredCredits; const lifetimeEarned = transactions .filter(c => c.amount > 0) .reduce((sum, c) => sum + c.amount, 0); const lifetimeSpent = Math.abs(transactions .filter(c => c.amount < 0) .reduce((sum, c) => sum + c.amount, 0)); // Pending credits (transactions that might be waiting for confirmation) const pendingCredits = transactions .filter(c => c.reference_type === 'pending_membership' || c.reference_type === 'pending_bonus') .reduce((sum, c) => sum + (c.amount > 0 ? c.amount : 0), 0); return { user_id: userId, total_balance: totalBalance, available_balance, expired_credits: expiredCredits, pending_credits: pendingCredits, lifetime_earned: lifetimeEarned, lifetime_spent: lifetimeSpent, }; } // Add credits to user account async addCredits( userId: string, amount: number, transactionType: 'earned' | 'bonus' = 'earned', referenceId?: string, referenceType?: string, description?: string, expiresAt?: Date ): Promise<Credit> { try { // Use the database function for atomic credit addition const { data, error } = await supabase .rpc('add_credits', { target_user_id: userId, credit_amount: amount, transaction_type: transactionType, ref_id: referenceId, ref_type: referenceType, description: description, expires_at: expiresAt?.toISOString(), }); if (error) { console.error('Error adding credits:', error); throw error; } // Fetch the created credit transaction const { data: creditTransaction, error: fetchError } = await supabase .from('credits') .select(` *, user:users(*) `) .eq('id', data) .single(); if (fetchError) { console.error('Error fetching created credit transaction:', fetchError); throw fetchError; } return creditTransaction; } catch (error) { console.error('Error in addCredits:', error); throw error; } } // Spend credits (deduct from user account) async spendCredits( userId: string, amount: number, referenceId?: string, referenceType?: string, description?: string ): Promise<Credit> { // Check if user has sufficient balance const currentBalance = await this.getUserCreditBalance(userId); if (currentBalance < amount) { throw new Error(`Insufficient credits. Available: ${currentBalance}, Required: ${amount}`); } return this.addCredits( userId, -amount, // Negative amount for spending 'spent', referenceId, referenceType, description ); } // Refund credits async refundCredits( userId: string, amount: number, originalTransactionId: string, description?: string ): Promise<Credit> { return this.addCredits( userId, amount, 'refunded', originalTransactionId, 'refund', description || 'Credit refund' ); } // Get credit transaction history async getCreditHistory( filters: CreditFilters = {}, limit: number = 50, offset: number = 0 ): Promise<Credit[]> { let query = supabase .from('credits') .select(` *, user:users(*) `); // Apply filters if (filters.user_id) { query = query.eq('user_id', filters.user_id); } if (filters.transaction_type) { query = query.eq('transaction_type', filters.transaction_type); } if (filters.reference_type) { query = query.eq('reference_type', filters.reference_type); } if (filters.date_from) { query = query.gte('created_at', filters.date_from); } if (filters.date_to) { query = query.lte('created_at', filters.date_to); } if (!filters.include_expired) { const now = new Date().toISOString(); query = query.or(`expires_at.is.null,expires_at.gt.${now}`); } const { data, error } = await query .order('created_at', { ascending: false }) .range(offset, offset + limit - 1); if (error) { console.error('Error fetching credit history:', error); throw error; } return data || []; } // Award monthly membership credits async awardMembershipCredits( userId: string, membershipTier: 'basic' | 'premium' | 'vip', membershipId?: string ): Promise<Credit> { const creditAmounts: MembershipCredits = { basic: 10, premium: 20, vip: 30, }; const amount = creditAmounts[membershipTier]; return this.addCredits( userId, amount, 'earned', membershipId, 'membership_renewal', `Monthly ${membershipTier} membership credits`, // Credits expire after 12 months new Date(Date.now() + 365 * 24 * 60 * 60 * 1000) ); } // Award bonus credits (promotions, referrals, etc.) async awardBonusCredits( userId: string, amount: number, reason: string, referenceId?: string, expiresAt?: Date ): Promise<Credit> { return this.addCredits( userId, amount, 'bonus', referenceId, 'bonus', reason, expiresAt ); } // Process reservation credit transaction async processReservationCredits( userId: string, offerId: string, creditCost: number, reservationId: string ): Promise<Credit> { return this.spendCredits( userId, creditCost, reservationId, 'reservation', `Credits used for reservation ${reservationId}` ); } // Refund reservation credits (when reservation is cancelled) async refundReservationCredits( userId: string, creditAmount: number, originalReservationId: string ): Promise<Credit> { return this.refundCredits( userId, creditAmount, originalReservationId, `Refund for cancelled reservation ${originalReservationId}` ); } // Get credits expiring soon async getExpiringCredits( userId: string, daysAhead: number = 30 ): Promise<Credit[]> { const futureDate = new Date(); futureDate.setDate(futureDate.getDate() + daysAhead); const { data, error } = await supabase .from('credits') .select(` *, user:users(*) `) .eq('user_id', userId) .gt('amount', 0) // Only positive amounts (earned credits) .lte('expires_at', futureDate.toISOString()) .order('expires_at', { ascending: true }); if (error) { console.error('Error fetching expiring credits:', error); throw error; } return data || []; } // Expire old credits (background job) async expireOldCredits(): Promise<number> { const now = new Date().toISOString(); // This would typically be a database function or stored procedure // For now, we'll mark expired credits const { data: expiredCredits, error: fetchError } = await supabase .from('credits') .select('id, user_id, amount') .lt('expires_at', now) .gt('amount', 0) // Only positive amounts .eq('transaction_type', 'earned'); // Only earned credits can expire if (fetchError) { console.error('Error fetching expired credits:', fetchError); throw fetchError; } let expiredCount = 0; // Process each expired credit for (const credit of expiredCredits || []) { try { await this.addCredits( credit.user_id, -credit.amount, 'expired', credit.id, 'expiration', 'Credits expired' ); expiredCount++; } catch (error) { console.error(`Error expiring credit ${credit.id}:`, error); } } return expiredCount; } // Get credit statistics for analytics async getCreditStats( userId?: string, dateFrom?: string, dateTo?: string ): Promise<{ totalEarned: number; totalSpent: number; totalRefunded: number; totalExpired: number; totalBonus: number; activeUsers: number; avgBalance: number; }> { let query = supabase .from('credits') .select('transaction_type, amount, user_id'); if (userId) { query = query.eq('user_id', userId); } if (dateFrom) { query = query.gte('created_at', dateFrom); } if (dateTo) { query = query.lte('created_at', dateTo); } const { data: transactions, error } = await query; if (error) { console.error('Error fetching credit stats:', error); throw error; } const stats = (transactions || []).reduce( (acc, transaction) => { switch (transaction.transaction_type) { case 'earned': acc.totalEarned += transaction.amount; break; case 'spent': acc.totalSpent += Math.abs(transaction.amount); break; case 'refunded': acc.totalRefunded += transaction.amount; break; case 'expired': acc.totalExpired += Math.abs(transaction.amount); break; case 'bonus': acc.totalBonus += transaction.amount; break; } return acc; }, { totalEarned: 0, totalSpent: 0, totalRefunded: 0, totalExpired: 0, totalBonus: 0, activeUsers: 0, avgBalance: 0, } ); // Calculate active users (users with transactions) const uniqueUsers = new Set((transactions || []).map(t => t.user_id)); stats.activeUsers = uniqueUsers.size; // Calculate average balance (would need current balances for all users) stats.avgBalance = 0; // TODO: Implement proper calculation return stats; } // Transfer credits between users (admin only) async transferCredits( fromUserId: string, toUserId: string, amount: number, reason: string, adminId: string ): Promise<{ debitTransaction: Credit; creditTransaction: Credit }> { // Check if source user has sufficient balance const fromBalance = await this.getUserCreditBalance(fromUserId); if (fromBalance < amount) { throw new Error(`Insufficient credits for transfer. Available: ${fromBalance}, Required: ${amount}`); } // Create both transactions const debitTransaction = await this.spendCredits( fromUserId, amount, toUserId, 'transfer_out', `Transfer to ${toUserId}: ${reason}` ); const creditTransaction = await this.addCredits( toUserId, amount, 'earned', fromUserId, 'transfer_in', `Transfer from ${fromUserId}: ${reason}` ); return { debitTransaction, creditTransaction }; } // Get top credit earners (leaderboard) async getTopCreditEarners(limit: number = 10): Promise<any[]> { // This would typically be a database view or function // For now, we'll aggregate in the application const { data: transactions, error } = await supabase .from('credits') .select(` user_id, amount, user:users(full_name, avatar_url) `) .gt('amount', 0) .eq('transaction_type', 'earned'); if (error) { console.error('Error fetching credit earners:', error); throw error; } // Group by user and sum amounts const userTotals = (transactions || []).reduce((acc, transaction) => { if (!acc[transaction.user_id]) { acc[transaction.user_id] = { user_id: transaction.user_id, user: transaction.user, total_earned: 0, }; } acc[transaction.user_id].total_earned += transaction.amount; return acc; }, {} as Record<string, any>); return Object.values(userTotals) .sort((a: any, b: any) => b.total_earned - a.total_earned) .slice(0, limit); }
} export const creditsService = new CreditsService();