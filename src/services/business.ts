import { supabase } from '@/integrations/supabase/client';
import { Tables, TablesInsert, TablesUpdate } from '@/integrations/supabase/types';
import { ApiError, handleSupabaseError } from '@/lib/error-handling';
import { withRetry } from '@/lib/retry';
import { validateBusinessProfile } from '@/lib/validation'; export type BusinessProfile = Tables<'business_profiles'> & { user: Tables<'users'>; venues?: Tables<'venues'>[];
}; export type BusinessFilters = { search?: string; industry?: string; company_size?: string; location?: string; is_verified?: boolean;
}; class BusinessService { // Get all business profiles with filters async getBusinesses(filters: BusinessFilters = {}): Promise<BusinessProfile[]> { return withRetry(async () => { try { let query = supabase .from('business_profiles') .select(` *, user:users(*), venues(*) `); // Apply search filter with sanitization if (filters.search) { const sanitizedSearch = filters.search.replace(/[%_]/g, '\\$&'); query = query.or( `company_name.ilike.%${sanitizedSearch}%,description.ilike.%${sanitizedSearch}%,industry.ilike.%${sanitizedSearch}%` ); } // Apply industry filter if (filters.industry) { query = query.eq('industry', filters.industry); } // Apply company size filter if (filters.company_size) { query = query.eq('company_size', filters.company_size); } // Apply location filter if (filters.location) { const sanitizedLocation = filters.location.replace(/[%_]/g, '\\$&'); query = query.ilike('address', `%${sanitizedLocation}%`); } // Apply verification filter if (filters.is_verified !== undefined) { query = query.eq('is_verified_business', filters.is_verified); } const { data, error } = await query .order('created_at', { ascending: false }) .limit(50); // Add pagination limit if (error) { throw handleSupabaseError(error, 'Failed to fetch businesses'); } return data || []; } catch (error) { console.error('Error fetching businesses:', error); throw error instanceof ApiError ? error : new ApiError('Failed to fetch businesses', 500); } }, 3, 1000); } // Get single business profile by ID async getBusiness(id: string): Promise<BusinessProfile | null> { const { data, error } = await supabase .from('business_profiles') .select(` *, user:users(*), venues(*) `) .eq('id', id) .single(); if (error) { console.error('Error fetching business:', error); if (error.code === 'PGRST116') { return null; } throw error; } return data; } // Get business profile by user ID async getBusinessByUserId(userId: string): Promise<BusinessProfile | null> { const { data, error } = await supabase .from('business_profiles') .select(` *, user:users(*), venues(*) `) .eq('user_id', userId) .single(); if (error) { console.error('Error fetching business by user ID:', error); if (error.code === 'PGRST116') { return null; } throw error; } return data; } // Create new business profile async createBusinessProfile( userId: string, profileData: Omit<TablesInsert<'business_profiles'>, 'user_id'> ): Promise<BusinessProfile> { const { data, error } = await supabase .from('business_profiles') .insert({ user_id: userId, ...profileData, }) .select(` *, user:users(*), venues(*) `) .single(); if (error) { console.error('Error creating business profile:', error); throw error; } return data; } // Update business profile async updateBusinessProfile( id: string, updates: TablesUpdate<'business_profiles'> ): Promise<BusinessProfile> { const { data, error } = await supabase .from('business_profiles') .update({ ...updates, updated_at: new Date().toISOString(), }) .eq('id', id) .select(` *, user:users(*), venues(*) `) .single(); if (error) { console.error('Error updating business profile:', error); throw error; } return data; } // Get business analytics async getBusinessAnalytics(userId: string): Promise<Tables<'user_analytics'>[]> { const { data, error } = await supabase .from('user_analytics') .select('*') .eq('user_id', userId) .order('created_at', { ascending: false }); if (error) { console.error('Error fetching business analytics:', error); throw error; } return data || []; } // Search businesses async searchBusinesses(query: string, limit: number = 20): Promise<BusinessProfile[]> { const { data, error } = await supabase .from('business_profiles') .select(` *, user:users(*), venues(*) `) .or( `company_name.ilike.%${query}%,description.ilike.%${query}%,industry.ilike.%${query}%` ) .limit(limit) .order('is_verified_business', { ascending: false }); if (error) { console.error('Error searching businesses:', error); throw error; } return data || []; } // Get businesses by industry async getBusinessesByIndustry(industry: string, limit: number = 20): Promise<BusinessProfile[]> { const { data, error } = await supabase .from('business_profiles') .select(` *, user:users(*), venues(*) `) .eq('industry', industry) .order('is_verified_business', { ascending: false }) .limit(limit); if (error) { console.error('Error fetching businesses by industry:', error); throw error; } return data || []; } // Get verified businesses async getVerifiedBusinesses(limit: number = 20): Promise<BusinessProfile[]> { const { data, error } = await supabase .from('business_profiles') .select(` *, user:users(*), venues(*) `) .eq('is_verified_business', true) .order('average_rating', { ascending: false }) .limit(limit); if (error) { console.error('Error fetching verified businesses:', error); throw error; } return data || []; } // Update business verification status (admin only) async updateVerificationStatus(id: string, isVerified: boolean): Promise<BusinessProfile> { return this.updateBusinessProfile(id, { is_verified_business: isVerified, }); } // Add venue to business profile async addVenue( businessProfileId: string, venueData: Omit<TablesInsert<'venues'>, 'business_profile_id'> ): Promise<Tables<'venues'>> { const { data, error } = await supabase .from('venues') .insert({ business_profile_id: businessProfileId, ...venueData, }) .select() .single(); if (error) { console.error('Error adding venue:', error); throw error; } return data; } // Update venue async updateVenue( id: string, updates: TablesUpdate<'venues'> ): Promise<Tables<'venues'>> { const { data, error } = await supabase .from('venues') .update({ ...updates, updated_at: new Date().toISOString(), }) .eq('id', id) .select() .single(); if (error) { console.error('Error updating venue:', error); throw error; } return data; } // Delete venue async deleteVenue(id: string): Promise<void> { const { error } = await supabase .from('venues') .delete() .eq('id', id); if (error) { console.error('Error deleting venue:', error); throw error; } } // Get business collaboration history async getCollaborationHistory(businessId: string): Promise<any[]> { const { data, error } = await supabase .from('collaborations') .select(` *, creator_profile:creator_profiles( *, user:users(*) ) `) .eq('business_id', businessId) .order('created_at', { ascending: false }); if (error) { console.error('Error fetching collaboration history:', error); throw error; } return data || []; } // Get business dashboard stats async getBusinessDashboardStats(businessId: string): Promise<{ totalCampaigns: number; activeCampaigns: number; completedCampaigns: number; totalSpent: number; avgRating: number; totalReach: number; }> { // Get collaboration stats const { data: collaborations, error: collabError } = await supabase .from('collaborations') .select('status, compensation_amount') .eq('business_id', businessId); if (collabError) { console.error('Error fetching business dashboard stats:', collabError); throw collabError; } const totalCampaigns = collaborations?.length || 0; const activeCampaigns = collaborations?.filter(c => ['accepted', 'in_progress'].includes(c.status || '') ).length || 0; const completedCampaigns = collaborations?.filter(c => c.status === 'completed' ).length || 0; const totalSpent = collaborations?.reduce((sum, c) => sum + (c.compensation_amount || 0), 0 ) || 0; // TODO: Calculate avgRating from reviews const avgRating = 0; // TODO: Calculate totalReach from analytics const totalReach = 0; return { totalCampaigns, activeCampaigns, completedCampaigns, totalSpent, avgRating, totalReach, }; } // Get recent activity for business async getRecentActivity(businessId: string, limit: number = 10): Promise<any[]> { const { data, error } = await supabase .from('collaborations') .select(` *, creator_profile:creator_profiles( *, user:users(full_name, avatar_url) ) `) .eq('business_id', businessId) .order('updated_at', { ascending: false }) .limit(limit); if (error) { console.error('Error fetching recent activity:', error); throw error; } return data || []; }
} export const businessService = new BusinessService();