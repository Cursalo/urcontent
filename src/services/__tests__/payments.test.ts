import { describe, it, expect, vi, beforeEach } from 'vitest' // Mock Supabase before importing the service
vi.mock('@/integrations/supabase/client', () => { const mockFromChain = () => ({ select: vi.fn().mockReturnThis(), insert: vi.fn().mockReturnThis(), update: vi.fn().mockReturnThis(), eq: vi.fn().mockReturnThis(), gte: vi.fn().mockReturnThis(), lte: vi.fn().mockReturnThis(), or: vi.fn().mockReturnThis(), order: vi.fn().mockReturnThis(), range: vi.fn().mockReturnThis(), single: vi.fn(), }) const mockSupabase = { from: vi.fn(() => mockFromChain()), } return { supabase: mockSupabase, }
}) import { paymentsService } from '../payments'
import { createMockPayment } from '@/__tests__/test-utils'
import { supabase } from '@/integrations/supabase/client' // Get the mocked supabase instance
const mockSupabase = vi.mocked(supabase) describe('PaymentsService', () => { beforeEach(() => { vi.clearAllMocks() }) describe('getPayments', () => { it('fetches payments with default parameters', async () => { const mockPayments = [createMockPayment(), createMockPayment({ id: 'payment-2' })] (mockSupabase.from as any)().range.mockResolvedValue({ data: mockPayments, error: null }) const payments = await paymentsService.getPayments() expect(mockSupabase.from).toHaveBeenCalledWith('payments') expect(payments).toEqual(mockPayments) }) it('applies user_id filter correctly', async () => { const mockPayments = [createMockPayment()] (mockSupabase.from as any)().range.mockResolvedValue({ data: mockPayments, error: null }) await paymentsService.getPayments({ user_id: 'test-user-id' }) expect((mockSupabase.from as any)().eq).toHaveBeenCalledWith('user_id', 'test-user-id') }) it('applies type filter correctly', async () => { const mockPayments = [createMockPayment({ type: 'collaboration' })] (mockSupabase.from as any)().range.mockResolvedValue({ data: mockPayments, error: null }) await paymentsService.getPayments({ type: 'collaboration' }) expect((mockSupabase.from as any)().eq).toHaveBeenCalledWith('type', 'collaboration') }) it('applies status filter correctly', async () => { const mockPayments = [createMockPayment({ status: 'approved' })] (mockSupabase.from as any)().range.mockResolvedValue({ data: mockPayments, error: null }) await paymentsService.getPayments({ status: 'approved' }) expect((mockSupabase.from as any)().eq).toHaveBeenCalledWith('status', 'approved') }) it('applies date range filters correctly', async () => { const mockPayments = [createMockPayment()] (mockSupabase.from as any)().range.mockResolvedValue({ data: mockPayments, error: null }) await paymentsService.getPayments({ date_from: '2024-01-01', date_to: '2024-12-31', }) expect((mockSupabase.from as any)().gte).toHaveBeenCalledWith('created_at', '2024-01-01') expect((mockSupabase.from as any)().lte).toHaveBeenCalledWith('created_at', '2024-12-31') }) it('applies amount range filters correctly', async () => { const mockPayments = [createMockPayment()] (mockSupabase.from as any)().range.mockResolvedValue({ data: mockPayments, error: null }) await paymentsService.getPayments({ amount_min: 1000, amount_max: 5000, }) expect((mockSupabase.from as any)().gte).toHaveBeenCalledWith('amount', 1000) expect((mockSupabase.from as any)().lte).toHaveBeenCalledWith('amount', 5000) }) it('applies search term filter correctly', async () => { const mockPayments = [createMockPayment()] (mockSupabase.from as any)().range.mockResolvedValue({ data: mockPayments, error: null }) await paymentsService.getPayments({ search_term: 'membership' }) expect((mockSupabase.from as any)().or).toHaveBeenCalledWith( 'description.ilike.%membership%,transaction_id.ilike.%membership%' ) }) it('handles pagination correctly', async () => { const mockPayments = [createMockPayment()] (mockSupabase.from as any)().range.mockResolvedValue({ data: mockPayments, error: null }) await paymentsService.getPayments({}, 25, 50) expect((mockSupabase.from as any)().range).toHaveBeenCalledWith(50, 74) }) it('throws error when Supabase returns error', async () => { const mockError = new Error('Database error') (mockSupabase.from as any)().range.mockResolvedValue({ data: null, error: mockError }) await expect(paymentsService.getPayments()).rejects.toThrow('Database error') }) it('returns empty array when no data', async () => { (mockSupabase.from as any)().range.mockResolvedValue({ data: null, error: null }) const payments = await paymentsService.getPayments() expect(payments).toEqual([]) }) }) describe('getPayment', () => { it('fetches single payment by ID', async () => { const mockPayment = createMockPayment() (mockSupabase.from as any)().single.mockResolvedValue({ data: mockPayment, error: null }) const payment = await paymentsService.getPayment('test-payment-id') expect(mockSupabase.from).toHaveBeenCalledWith('payments') expect((mockSupabase.from as any)().eq).toHaveBeenCalledWith('id', 'test-payment-id') expect(payment).toEqual(mockPayment) }) it('returns null when payment not found', async () => { (mockSupabase.from as any)().single.mockResolvedValue({ data: null, error: { code: 'PGRST116' } }) const payment = await paymentsService.getPayment('non-existent-id') expect(payment).toBeNull() }) it('throws error for other database errors', async () => { const mockError = new Error('Database connection error') (mockSupabase.from as any)().single.mockResolvedValue({ data: null, error: mockError }) await expect(paymentsService.getPayment('test-id')).rejects.toThrow('Database connection error') }) }) describe('getPaymentByMPId', () => { it('fetches payment by MercadoPago ID', async () => { const mockPayment = createMockPayment({ mercadopago_payment_id: 'mp-123' }) (mockSupabase.from as any)().single.mockResolvedValue({ data: mockPayment, error: null }) const payment = await paymentsService.getPaymentByMPId('mp-123') expect((mockSupabase.from as any)().eq).toHaveBeenCalledWith('mercadopago_payment_id', 'mp-123') expect(payment).toEqual(mockPayment) }) it('returns null when payment not found', async () => { (mockSupabase.from as any)().single.mockResolvedValue({ data: null, error: { code: 'PGRST116' } }) const payment = await paymentsService.getPaymentByMPId('non-existent-mp-id') expect(payment).toBeNull() }) }) describe('createPayment', () => { it('creates payment with correct data', async () => { const mockPayment = createMockPayment() (mockSupabase.from as any)().single.mockResolvedValue({ data: mockPayment, error: null }) const paymentData = { user_id: 'test-user-id', type: 'membership' as const, amount: 29990, description: 'Test Payment', payment_method: 'MercadoPago', } const payment = await paymentsService.createPayment(paymentData) expect(mockSupabase.from).toHaveBeenCalledWith('payments') expect((mockSupabase.from as any)().insert).toHaveBeenCalledWith( expect.objectContaining({ user_id: 'test-user-id', type: 'membership', status: 'pending', amount: 29990, currency: 'ARS', description: 'Test Payment', payment_method: 'MercadoPago', transaction_id: expect.stringMatching(/^TXN-\d+-.{9}$/), }) ) expect(payment).toEqual(mockPayment) }) it('creates payment with custom currency', async () => { const mockPayment = createMockPayment({ currency: 'USD' }) (mockSupabase.from as any)().single.mockResolvedValue({ data: mockPayment, error: null }) const paymentData = { user_id: 'test-user-id', type: 'membership' as const, amount: 2999, currency: 'USD', description: 'Test Payment', payment_method: 'MercadoPago', } await paymentsService.createPayment(paymentData) expect((mockSupabase.from as any)().insert).toHaveBeenCalledWith( expect.objectContaining({ currency: 'USD', }) ) }) it('includes optional fields when provided', async () => { const mockPayment = createMockPayment() (mockSupabase.from as any)().single.mockResolvedValue({ data: mockPayment, error: null }) const paymentData = { user_id: 'test-user-id', type: 'collaboration' as const, amount: 50000, description: 'Collaboration Payment', payment_method: 'MercadoPago', reference_id: 'collab-123', reference_type: 'collaboration', metadata: { campaign: 'summer-2024' }, } await paymentsService.createPayment(paymentData) expect((mockSupabase.from as any)().insert).toHaveBeenCalledWith( expect.objectContaining({ reference_id: 'collab-123', reference_type: 'collaboration', metadata: { campaign: 'summer-2024' }, }) ) }) it('throws error when creation fails', async () => { const mockError = new Error('Database error') (mockSupabase.from as any)().single.mockResolvedValue({ data: null, error: mockError }) const paymentData = { user_id: 'test-user-id', type: 'membership' as const, amount: 29990, description: 'Test Payment', payment_method: 'MercadoPago', } await expect(paymentsService.createPayment(paymentData)).rejects.toThrow('Database error') }) }) describe('updatePaymentStatus', () => { it('updates payment status to approved', async () => { const mockPayment = createMockPayment({ status: 'approved' }) (mockSupabase.from as any)().single.mockResolvedValue({ data: mockPayment, error: null }) const payment = await paymentsService.updatePaymentStatus( 'test-payment-id', 'approved', 'mp-123' ) expect((mockSupabase.from as any)().update).toHaveBeenCalledWith( expect.objectContaining({ status: 'approved', mercadopago_payment_id: 'mp-123', processed_at: expect.any(String), updated_at: expect.any(String), }) ) expect(payment).toEqual(mockPayment) }) it('updates payment status to rejected with failure reason', async () => { const mockPayment = createMockPayment({ status: 'rejected' }) (mockSupabase.from as any)().single.mockResolvedValue({ data: mockPayment, error: null }) await paymentsService.updatePaymentStatus( 'test-payment-id', 'rejected', 'mp-123', 'Insufficient funds' ) expect((mockSupabase.from as any)().update).toHaveBeenCalledWith( expect.objectContaining({ status: 'rejected', failed_at: expect.any(String), failure_reason: 'Insufficient funds', }) ) }) it('updates payment status to refunded', async () => { const mockPayment = createMockPayment({ status: 'refunded' }) (mockSupabase.from as any)().single.mockResolvedValue({ data: mockPayment, error: null }) await paymentsService.updatePaymentStatus('test-payment-id', 'refunded') expect((mockSupabase.from as any)().update).toHaveBeenCalledWith( expect.objectContaining({ status: 'refunded', refunded_at: expect.any(String), }) ) }) }) describe('getPaymentStats', () => { it('calculates payment statistics correctly', async () => { const mockPayments = [ createMockPayment({ status: 'approved', amount: 10000, type: 'membership' }), createMockPayment({ status: 'approved', amount: 20000, type: 'collaboration' }), createMockPayment({ status: 'pending', amount: 15000, type: 'membership' }), createMockPayment({ status: 'rejected', amount: 5000, type: 'experience' }), ] (mockSupabase.from as any)().range.mockResolvedValue({ data: mockPayments, error: null }) const stats = await paymentsService.getPaymentStats() expect(stats.total_approved).toBe(2) expect(stats.total_pending).toBe(1) expect(stats.total_rejected).toBe(1) expect(stats.total_amount_approved).toBe(30000) expect(stats.total_amount_pending).toBe(15000) expect(stats.total_transactions).toBe(4) expect(stats.avg_transaction_amount).toBe(12500) expect(stats.by_type.membership.count).toBe(2) expect(stats.by_type.membership.amount).toBe(25000) expect(stats.by_type.collaboration.count).toBe(1) expect(stats.by_type.collaboration.amount).toBe(20000) }) it('handles empty payment list', async () => { (mockSupabase.from as any)().range.mockResolvedValue({ data: [], error: null }) const stats = await paymentsService.getPaymentStats() expect(stats.total_transactions).toBe(0) expect(stats.avg_transaction_amount).toBe(0) expect(stats.total_amount_approved).toBe(0) }) }) describe('createMembershipPayment', () => { it('creates basic membership payment with correct amount', async () => { const mockPayment = createMockPayment() (mockSupabase.from as any)().single.mockResolvedValue({ data: mockPayment, error: null }) await paymentsService.createMembershipPayment('user-123', 'basic', 'membership-456') expect((mockSupabase.from as any)().insert).toHaveBeenCalledWith( expect.objectContaining({ user_id: 'user-123', type: 'membership', amount: 299900, // $2,999 in cents description: 'URContent Basic - Plan Mensual', reference_id: 'membership-456', reference_type: 'membership', metadata: { membership_tier: 'basic', billing_period: 'monthly', }, }) ) }) it('creates premium membership payment with correct amount', async () => { const mockPayment = createMockPayment() (mockSupabase.from as any)().single.mockResolvedValue({ data: mockPayment, error: null }) await paymentsService.createMembershipPayment('user-123', 'premium', 'membership-456') expect((mockSupabase.from as any)().insert).toHaveBeenCalledWith( expect.objectContaining({ amount: 899900, // $8,999 in cents description: 'URContent Premium - Plan Mensual', }) ) }) it('creates VIP membership payment with correct amount', async () => { const mockPayment = createMockPayment() (mockSupabase.from as any)().single.mockResolvedValue({ data: mockPayment, error: null }) await paymentsService.createMembershipPayment('user-123', 'vip', 'membership-456') expect((mockSupabase.from as any)().insert).toHaveBeenCalledWith( expect.objectContaining({ amount: 1999900, // $19,999 in cents description: 'URContent Vip - Plan Mensual', }) ) }) }) describe('processMercadoPageWebhook', () => { it('processes approved payment webhook', async () => { const mockPayment = createMockPayment({ mercadopago_payment_id: 'mp-123' }) (mockSupabase.from as any)().single .mockResolvedValueOnce({ data: mockPayment, error: null }) // getPaymentByMPId .mockResolvedValueOnce({ data: { ...mockPayment, status: 'approved' }, error: null }) // updatePaymentStatus const result = await paymentsService.processMercadoPageWebhook('mp-123', 'approved') expect(result?.status).toBe('approved') }) it('processes rejected payment webhook', async () => { const mockPayment = createMockPayment({ mercadopago_payment_id: 'mp-123' }) (mockSupabase.from as any)().single .mockResolvedValueOnce({ data: mockPayment, error: null }) .mockResolvedValueOnce({ data: { ...mockPayment, status: 'rejected' }, error: null }) const result = await paymentsService.processMercadoPageWebhook('mp-123', 'rejected', 'cc_rejected_insufficient_amount') expect(result?.status).toBe('rejected') }) it('returns null when payment not found', async () => { (mockSupabase.from as any)().single.mockResolvedValue({ data: null, error: { code: 'PGRST116' } }) const result = await paymentsService.processMercadoPageWebhook('non-existent-mp-id', 'approved') expect(result).toBeNull() }) it('handles unknown payment status', async () => { const mockPayment = createMockPayment({ mercadopago_payment_id: 'mp-123' }) (mockSupabase.from as any)().single.mockResolvedValue({ data: mockPayment, error: null }) const result = await paymentsService.processMercadoPageWebhook('mp-123', 'unknown_status') expect(result).toEqual(mockPayment) // Returns original payment without update }) }) describe('exportPayments', () => { it('exports payments to CSV format', async () => { const mockPayments = [ createMockPayment({ id: 'payment-1', user_id: 'user-1', type: 'membership', status: 'approved', amount: 29990, description: 'Basic Membership', }), createMockPayment({ id: 'payment-2', user_id: 'user-2', type: 'collaboration', status: 'pending', amount: 50000, description: 'Collaboration Fee', }), ] (mockSupabase.from as any)().range.mockResolvedValue({ data: mockPayments, error: null }) const csvContent = await paymentsService.exportPayments() expect(csvContent).toContain('ID,Fecha,Usuario,Tipo,Estado,Monto') expect(csvContent).toContain('"payment-1"') expect(csvContent).toContain('"payment-2"') expect(csvContent).toContain('"membership"') expect(csvContent).toContain('"collaboration"') expect(csvContent).toContain('"approved"') expect(csvContent).toContain('"pending"') }) it('handles empty payment list', async () => { (mockSupabase.from as any)().range.mockResolvedValue({ data: [], error: null }) const csvContent = await paymentsService.exportPayments() expect(csvContent).toContain('ID,Fecha,Usuario,Tipo,Estado,Monto') // Should only contain headers expect(csvContent.split('\n')).toHaveLength(2) // Header + empty line }) }) describe('refundPayment', () => { it('refunds approved payment successfully', async () => { const mockPayment = createMockPayment({ status: 'approved' }) (mockSupabase.from as any)().single .mockResolvedValueOnce({ data: mockPayment, error: null }) // getPayment .mockResolvedValueOnce({ data: { ...mockPayment, status: 'refunded' }, error: null }) // updatePaymentStatus const result = await paymentsService.refundPayment('payment-123', 'Customer request') expect(result.status).toBe('refunded') }) it('throws error when payment not found', async () => { (mockSupabase.from as any)().single.mockResolvedValue({ data: null, error: null }) await expect(paymentsService.refundPayment('non-existent-id')).rejects.toThrow('Payment not found') }) it('throws error when payment is not approved', async () => { const mockPayment = createMockPayment({ status: 'pending' }) (mockSupabase.from as any)().single.mockResolvedValue({ data: mockPayment, error: null }) await expect(paymentsService.refundPayment('payment-123')).rejects.toThrow('Only approved payments can be refunded') }) })
})