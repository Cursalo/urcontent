// Mock Data Validation - ensures data integrity and type safety
// This file provides validation schemas and functions for all mock data types
// Designed to catch data inconsistencies before database migration import { z } from 'zod'; // Base validation schemas
export const UUIDSchema = z.string().uuid();
export const ISODateSchema = z.string().datetime();
export const EmailSchema = z.string().email();
export const URLSchema = z.string().url().optional().nullable();
export const PositiveNumberSchema = z.number().positive();
export const NonNegativeNumberSchema = z.number().min(0); // User validation schema
export const MockUserSchema = z.object({ id: UUIDSchema, email: EmailSchema, password: z.string().min(6), full_name: z.string().min(1), role: z.enum(['creator', 'business', 'admin']), username: z.string().nullable(), avatar_url: URLSchema, phone: z.string().nullable(), location: z.string().nullable(), timezone: z.string().nullable(), language: z.string().nullable(), is_verified: z.boolean(), verification_status: z.enum(['pending', 'verified', 'rejected']), created_at: ISODateSchema, updated_at: ISODateSchema.nullable(), last_seen_at: ISODateSchema.nullable(), metadata: z.any().optional()
}); // Creator Profile validation schema
export const MockCreatorProfileSchema = z.object({ id: UUIDSchema, user_id: UUIDSchema, bio: z.string().min(10).max(1000), specialties: z.array(z.string()).min(1), rating: z.number().min(0).max(5), ur_score: z.number().min(0).max(100), instagram_followers: NonNegativeNumberSchema, tiktok_followers: NonNegativeNumberSchema, youtube_followers: NonNegativeNumberSchema, instagram_handle: z.string().nullable(), tiktok_handle: z.string().nullable(), youtube_handle: z.string().nullable(), engagement_rate: z.number().min(0).max(100), min_collaboration_fee: NonNegativeNumberSchema, max_collaboration_fee: PositiveNumberSchema, is_available: z.boolean(), public_slug: z.string().min(1), years_experience: NonNegativeNumberSchema, preferred_brands: z.array(z.string()), content_style: z.array(z.string()), rates_per_post: NonNegativeNumberSchema, rates_per_story: NonNegativeNumberSchema, rates_per_reel: NonNegativeNumberSchema, rates_per_video: NonNegativeNumberSchema, location_preferences: z.array(z.string()), languages_spoken: z.array(z.string()), created_at: ISODateSchema, updated_at: ISODateSchema
}).refine(data => data.max_collaboration_fee >= data.min_collaboration_fee, { message:"Max collaboration fee must be greater than or equal to min collaboration fee", path: ["max_collaboration_fee"]
}); // Business Profile validation schema
export const MockBusinessProfileSchema = z.object({ id: UUIDSchema, user_id: UUIDSchema, company_name: z.string().min(1), description: z.string().min(10).max(2000), industry: z.string().min(1), company_size: z.enum(['1-10', '11-50', '51-200', '201-1000', '1000+']), website_url: URLSchema, logo_url: URLSchema, address: z.string().nullable(), city: z.string().nullable(), country: z.string().nullable(), is_verified_business: z.boolean(), verification_documents: z.array(z.string()).nullable(), tax_id: z.string().nullable(), business_registration: z.string().nullable(), contact_email: EmailSchema, contact_phone: z.string().nullable(), social_media: z.object({ instagram: z.string().optional(), facebook: z.string().optional(), twitter: z.string().optional(), linkedin: z.string().optional(), website: z.string().optional() }), campaign_budget_range: z.object({ min: NonNegativeNumberSchema, max: PositiveNumberSchema }).refine(data => data.max >= data.min, { message:"Max budget must be greater than or equal to min budget", path: ["max"] }), preferred_creator_tiers: z.array(z.enum(['nano', 'micro', 'macro', 'mega'])), target_audience: z.object({ age_range: z.tuple([z.number().min(13), z.number().max(100)]), genders: z.array(z.string()), interests: z.array(z.string()), locations: z.array(z.string()) }), collaboration_history: z.object({ total_campaigns: NonNegativeNumberSchema, successful_campaigns: NonNegativeNumberSchema, average_rating: z.number().min(0).max(5), total_spent: NonNegativeNumberSchema }).refine(data => data.successful_campaigns <= data.total_campaigns, { message:"Successful campaigns cannot exceed total campaigns", path: ["successful_campaigns"] }), created_at: ISODateSchema, updated_at: ISODateSchema
}); // Portfolio Item validation schema
export const MockPortfolioItemSchema = z.object({ id: UUIDSchema, creator_id: UUIDSchema, title: z.string().min(1).max(200), description: z.string().min(1).max(1000), media_url: z.string().url(), media_type: z.enum(['image', 'video', 'carousel', 'reel']), platform: z.enum(['instagram', 'tiktok', 'youtube', 'other']), engagement_stats: z.object({ likes: NonNegativeNumberSchema, comments: NonNegativeNumberSchema, shares: NonNegativeNumberSchema.optional(), saves: NonNegativeNumberSchema.optional(), views: NonNegativeNumberSchema.optional(), reach: NonNegativeNumberSchema.optional(), impressions: NonNegativeNumberSchema.optional(), engagement_rate: z.number().min(0).max(100) }), performance_metrics: z.object({ click_through_rate: z.number().min(0).max(100).optional(), conversion_rate: z.number().min(0).max(100).optional(), cost_per_engagement: z.number().min(0).optional() }), tags: z.array(z.string()), brand_mention: z.string().nullable(), campaign_id: z.string().nullable(), is_featured: z.boolean(), created_at: ISODateSchema, updated_at: ISODateSchema
}); // Collaboration validation schema
export const MockCollaborationSchema = z.object({ id: UUIDSchema, title: z.string().min(1).max(200), description: z.string().min(10).max(2000), business_id: UUIDSchema, creator_id: UUIDSchema, status: z.enum(['proposed', 'accepted', 'in_progress', 'completed', 'cancelled', 'rejected']), collaboration_type: z.enum(['sponsored_post', 'product_review', 'brand_partnership', 'event_coverage', 'ugc_creation']), platform: z.enum(['instagram', 'tiktok', 'youtube', 'multi_platform']), compensation_amount: NonNegativeNumberSchema, compensation_type: z.enum(['fixed', 'per_post', 'commission', 'product_exchange']), deliverables: z.object({ posts: NonNegativeNumberSchema, stories: NonNegativeNumberSchema, reels: NonNegativeNumberSchema, videos: NonNegativeNumberSchema, usage_rights: z.boolean(), exclusivity_period: NonNegativeNumberSchema, revisions_included: NonNegativeNumberSchema }), requirements: z.object({ hashtags: z.array(z.string()), mentions: z.array(z.string()), content_guidelines: z.string(), posting_schedule: z.string(), approval_required: z.boolean() }), timeline: z.object({ start_date: ISODateSchema, end_date: ISODateSchema, content_due_date: ISODateSchema, posting_start_date: ISODateSchema, posting_end_date: ISODateSchema }).refine(data => new Date(data.end_date) >= new Date(data.start_date), { message:"End date must be after start date", path: ["end_date"] }), created_at: ISODateSchema, updated_at: ISODateSchema, accepted_at: ISODateSchema.nullable(), started_at: ISODateSchema.nullable(), completed_at: ISODateSchema.nullable(), cancelled_at: ISODateSchema.nullable(), performance: z.object({ total_reach: NonNegativeNumberSchema, total_impressions: NonNegativeNumberSchema, total_engagement: NonNegativeNumberSchema, clicks: NonNegativeNumberSchema, conversions: NonNegativeNumberSchema, roi: z.number().min(0) }).nullable(), creator_response: z.string().nullable(), business_feedback: z.string().nullable(), rating_by_business: z.number().min(1).max(5).nullable(), rating_by_creator: z.number().min(1).max(5).nullable()
}); // Analytics validation schema
export const MockAnalyticsDataSchema = z.object({ id: UUIDSchema, user_id: UUIDSchema, period: z.enum(['daily', 'weekly', 'monthly']), date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/), // YYYY-MM-DD format metrics: z.object({ // Creator metrics follower_growth: NonNegativeNumberSchema.optional(), engagement_rate: z.number().min(0).max(100).optional(), reach: NonNegativeNumberSchema.optional(), impressions: NonNegativeNumberSchema.optional(), profile_views: NonNegativeNumberSchema.optional(), // Business metrics campaign_reach: NonNegativeNumberSchema.optional(), conversion_rate: z.number().min(0).max(100).optional(), roi: z.number().min(0).optional(), cost_per_engagement: z.number().min(0).optional(), brand_mentions: NonNegativeNumberSchema.optional() }), created_at: ISODateSchema
}); // Validation functions
export class MockDataValidator { static validateUser(user: any): { isValid: boolean; errors?: string[] } { try { MockUserSchema.parse(user); return { isValid: true }; } catch (error) { if (error instanceof z.ZodError) { return { isValid: false, errors: error.errors.map(e => `${e.path.join('.')}: ${e.message}`) }; } return { isValid: false, errors: ['Unknown validation error'] }; } } static validateCreatorProfile(profile: any): { isValid: boolean; errors?: string[] } { try { MockCreatorProfileSchema.parse(profile); return { isValid: true }; } catch (error) { if (error instanceof z.ZodError) { return { isValid: false, errors: error.errors.map(e => `${e.path.join('.')}: ${e.message}`) }; } return { isValid: false, errors: ['Unknown validation error'] }; } } static validateBusinessProfile(profile: any): { isValid: boolean; errors?: string[] } { try { MockBusinessProfileSchema.parse(profile); return { isValid: true }; } catch (error) { if (error instanceof z.ZodError) { return { isValid: false, errors: error.errors.map(e => `${e.path.join('.')}: ${e.message}`) }; } return { isValid: false, errors: ['Unknown validation error'] }; } } static validatePortfolioItem(item: any): { isValid: boolean; errors?: string[] } { try { MockPortfolioItemSchema.parse(item); return { isValid: true }; } catch (error) { if (error instanceof z.ZodError) { return { isValid: false, errors: error.errors.map(e => `${e.path.join('.')}: ${e.message}`) }; } return { isValid: false, errors: ['Unknown validation error'] }; } } static validateCollaboration(collaboration: any): { isValid: boolean; errors?: string[] } { try { MockCollaborationSchema.parse(collaboration); return { isValid: true }; } catch (error) { if (error instanceof z.ZodError) { return { isValid: false, errors: error.errors.map(e => `${e.path.join('.')}: ${e.message}`) }; } return { isValid: false, errors: ['Unknown validation error'] }; } } static validateAnalyticsData(analytics: any): { isValid: boolean; errors?: string[] } { try { MockAnalyticsDataSchema.parse(analytics); return { isValid: true }; } catch (error) { if (error instanceof z.ZodError) { return { isValid: false, errors: error.errors.map(e => `${e.path.join('.')}: ${e.message}`) }; } return { isValid: false, errors: ['Unknown validation error'] }; } } // Validate all mock data collections static validateAllMockData(data: { users: any[]; creatorProfiles: any[]; businessProfiles: any[]; portfolioItems: any[]; collaborations: any[]; analytics: any[]; }): { isValid: boolean; errors: string[] } { const errors: string[] = []; // Validate users data.users.forEach((user, index) => { const result = this.validateUser(user); if (!result.isValid) { errors.push(`User ${index}: ${result.errors?.join(', ')}`); } }); // Validate creator profiles data.creatorProfiles.forEach((profile, index) => { const result = this.validateCreatorProfile(profile); if (!result.isValid) { errors.push(`Creator Profile ${index}: ${result.errors?.join(', ')}`); } }); // Validate business profiles data.businessProfiles.forEach((profile, index) => { const result = this.validateBusinessProfile(profile); if (!result.isValid) { errors.push(`Business Profile ${index}: ${result.errors?.join(', ')}`); } }); // Validate portfolio items data.portfolioItems.forEach((item, index) => { const result = this.validatePortfolioItem(item); if (!result.isValid) { errors.push(`Portfolio Item ${index}: ${result.errors?.join(', ')}`); } }); // Validate collaborations data.collaborations.forEach((collaboration, index) => { const result = this.validateCollaboration(collaboration); if (!result.isValid) { errors.push(`Collaboration ${index}: ${result.errors?.join(', ')}`); } }); // Validate analytics data.analytics.forEach((analytics, index) => { const result = this.validateAnalyticsData(analytics); if (!result.isValid) { errors.push(`Analytics ${index}: ${result.errors?.join(', ')}`); } }); return { isValid: errors.length === 0, errors }; } // Check referential integrity static validateReferentialIntegrity(data: { users: any[]; creatorProfiles: any[]; businessProfiles: any[]; portfolioItems: any[]; collaborations: any[]; analytics: any[]; }): { isValid: boolean; errors: string[] } { const errors: string[] = []; const userIds = new Set(data.users.map(u => u.id)); const creatorIds = new Set(data.creatorProfiles.map(p => p.id)); const businessIds = new Set(data.businessProfiles.map(p => p.id)); // Check creator profiles reference valid users data.creatorProfiles.forEach(profile => { if (!userIds.has(profile.user_id)) { errors.push(`Creator profile ${profile.id} references non-existent user ${profile.user_id}`); } }); // Check business profiles reference valid users data.businessProfiles.forEach(profile => { if (!userIds.has(profile.user_id)) { errors.push(`Business profile ${profile.id} references non-existent user ${profile.user_id}`); } }); // Check portfolio items reference valid creators data.portfolioItems.forEach(item => { if (!creatorIds.has(item.creator_id)) { errors.push(`Portfolio item ${item.id} references non-existent creator ${item.creator_id}`); } }); // Check collaborations reference valid users data.collaborations.forEach(collaboration => { if (!userIds.has(collaboration.business_id)) { errors.push(`Collaboration ${collaboration.id} references non-existent business user ${collaboration.business_id}`); } if (!userIds.has(collaboration.creator_id)) { errors.push(`Collaboration ${collaboration.id} references non-existent creator user ${collaboration.creator_id}`); } }); // Check analytics reference valid users data.analytics.forEach(analytics => { if (!userIds.has(analytics.user_id)) { errors.push(`Analytics ${analytics.id} references non-existent user ${analytics.user_id}`); } }); return { isValid: errors.length === 0, errors }; }
} export default MockDataValidator;