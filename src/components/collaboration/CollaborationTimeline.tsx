import React from 'react';
import { motion } from 'framer-motion';
import { Calendar, CheckCircle, Clock, User, Send, Eye, Star, AlertTriangle, XCircle
} from 'lucide-react';
import { Card, CardContent } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import { formatDate, formatRelativeTime } from '@/lib/utils';
import { CollaborationData } from './CollaborationDetail'; interface TimelineEvent { id: string; type: 'created' | 'accepted' | 'started' | 'deliverable_submitted' | 'deliverable_approved' | 'deliverable_rejected' | 'message' | 'completed' | 'cancelled' | 'milestone'; title: string; description?: string; timestamp: string; actor: { name: string; avatar: string; role: 'business' | 'creator'; }; status?: 'completed' | 'pending' | 'upcoming'; metadata?: any;
} interface CollaborationTimelineProps { collaboration: CollaborationData; className?: string;
} const getEventIcon = (type: TimelineEvent['type']) => { switch (type) { case 'created': return <Send className="h-4 w-4"/>; case 'accepted': return <CheckCircle className="h-4 w-4"/>; case 'started': return <User className="h-4 w-4"/>; case 'deliverable_submitted': return <Eye className="h-4 w-4"/>; case 'deliverable_approved': return <CheckCircle className="h-4 w-4"/>; case 'deliverable_rejected': return <XCircle className="h-4 w-4"/>; case 'message': return <Send className="h-4 w-4"/>; case 'completed': return <Star className="h-4 w-4"/>; case 'cancelled': return <XCircle className="h-4 w-4"/>; case 'milestone': return <Calendar className="h-4 w-4"/>; default: return <Clock className="h-4 w-4"/>; }
}; const getEventColor = (type: TimelineEvent['type']) => { switch (type) { case 'created': return 'bg-gray-100 text-gray-700 border-gray-200'; case 'accepted': return 'bg-gray-100 text-gray-700 border-gray-200'; case 'started': return 'bg-gray-100 text-gray-700 border-gray-200'; case 'deliverable_submitted': return 'bg-gray-100 text-gray-700 border-gray-200'; case 'deliverable_approved': return 'bg-gray-100 text-gray-700 border-gray-200'; case 'deliverable_rejected': return 'bg-gray-100 text-gray-700 border-gray-200'; case 'message': return 'bg-gray-100 text-gray-600 border-gray-200'; case 'completed': return 'bg-gray-100 text-gray-700 border-gray-200'; case 'cancelled': return 'bg-gray-100 text-gray-700 border-gray-200'; case 'milestone': return 'bg-gray-100 text-gray-700 border-gray-200'; default: return 'bg-gray-100 text-gray-600 border-gray-200'; }
}; export const CollaborationTimeline: React.FC<CollaborationTimelineProps> = ({ collaboration, className = ''
}) => { // Generate timeline events from collaboration data const events: TimelineEvent[] = React.useMemo(() => { const timelineEvents: TimelineEvent[] = []; // Project created timelineEvents.push({ id: 'created', type: 'created', title: 'Proyecto creado', description: 'Se envió la propuesta de colaboración', timestamp: collaboration.timeline.created, actor: { name: collaboration.business.name, avatar: collaboration.business.logo, role: 'business' }, status: 'completed' }); // Project accepted if (collaboration.timeline.accepted) { timelineEvents.push({ id: 'accepted', type: 'accepted', title: 'Proyecto aceptado', description: 'El creator aceptó la propuesta', timestamp: collaboration.timeline.accepted, actor: { name: collaboration.creator.name, avatar: collaboration.creator.avatar, role: 'creator' }, status: 'completed' }); } // Project started if (collaboration.timeline.started) { timelineEvents.push({ id: 'started', type: 'started', title: 'Proyecto iniciado', description: 'Se comenzó a trabajar en los entregables', timestamp: collaboration.timeline.started, actor: { name: collaboration.creator.name, avatar: collaboration.creator.avatar, role: 'creator' }, status: 'completed' }); } // Deliverable events collaboration.deliverables.forEach((deliverable, index) => { if (deliverable.submittedAt) { timelineEvents.push({ id: `deliverable-${deliverable.id}-submitted`, type: 'deliverable_submitted', title: `Entregable enviado: ${deliverable.title}`, description: 'Enviado para revisión', timestamp: deliverable.submittedAt, actor: { name: collaboration.creator.name, avatar: collaboration.creator.avatar, role: 'creator' }, status: 'completed', metadata: { deliverable } }); } if (deliverable.approvedAt) { timelineEvents.push({ id: `deliverable-${deliverable.id}-approved`, type: 'deliverable_approved', title: `Entregable aprobado: ${deliverable.title}`, description: 'Aprobado por el cliente', timestamp: deliverable.approvedAt, actor: { name: collaboration.business.name, avatar: collaboration.business.logo, role: 'business' }, status: 'completed', metadata: { deliverable } }); } if (deliverable.rejectedAt) { timelineEvents.push({ id: `deliverable-${deliverable.id}-rejected`, type: 'deliverable_rejected', title: `Entregable rechazado: ${deliverable.title}`, description: deliverable.feedback || 'Necesita revisiones', timestamp: deliverable.rejectedAt, actor: { name: collaboration.business.name, avatar: collaboration.business.logo, role: 'business' }, status: 'completed', metadata: { deliverable } }); } // Add milestone for pending deliverables if (deliverable.status === 'pending' || deliverable.status === 'in_progress') { timelineEvents.push({ id: `deliverable-${deliverable.id}-milestone`, type: 'milestone', title: `Fecha límite: ${deliverable.title}`, description: `Debe ser entregado antes del ${formatDate(deliverable.dueDate)}`, timestamp: deliverable.dueDate, actor: { name: collaboration.creator.name, avatar: collaboration.creator.avatar, role: 'creator' }, status: new Date(deliverable.dueDate) > new Date() ? 'upcoming' : 'pending', metadata: { deliverable } }); } }); // Recent messages (last 5) const recentMessages = collaboration.messages .slice(-5) .map(message => ({ id: `message-${message.id}`, type: 'message' as const, title: 'Nuevo mensaje', description: message.message.length > 100 ? message.message.substring(0, 100) + '...' : message.message, timestamp: message.timestamp, actor: { name: message.senderName, avatar: message.senderAvatar, role: message.senderId === collaboration.business.id ? 'business' as const : 'creator' as const }, status: 'completed' as const })); timelineEvents.push(...recentMessages); // Project completed if (collaboration.timeline.completed) { timelineEvents.push({ id: 'completed', type: 'completed', title: 'Proyecto completado', description: 'Todos los entregables han sido aprobados', timestamp: collaboration.timeline.completed, actor: { name: collaboration.business.name, avatar: collaboration.business.logo, role: 'business' }, status: 'completed' }); } // Project deadline milestone if (collaboration.status !== 'completed' && collaboration.status !== 'cancelled') { timelineEvents.push({ id: 'deadline', type: 'milestone', title: 'Fecha límite del proyecto', description: 'Fecha final para la entrega completa', timestamp: collaboration.timeline.deadline, actor: { name: collaboration.creator.name, avatar: collaboration.creator.avatar, role: 'creator' }, status: new Date(collaboration.timeline.deadline) > new Date() ? 'upcoming' : 'pending' }); } // Sort by timestamp return timelineEvents.sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime() ); }, [collaboration]); return ( <Card className={className}> <CardContent className="pt-6"> <div className="space-y-6"> <h3 className="text-lg font-semibold">Timeline del proyecto</h3> <div className="relative"> {/* Timeline line */} <div className="absolute left-6 top-0 bottom-0 w-0.5 bg-border"/> <div className="space-y-6"> {events.map((event, index) => { const isLast = index === events.length - 1; const isPast = new Date(event.timestamp) <= new Date(); const isUpcoming = event.status === 'upcoming'; const isPending = event.status === 'pending'; return ( <motion.div key={event.id} initial={{ opacity: 0, x: -20 }} animate={{ opacity: 1, x: 0 }} transition={{ delay: index * 0.1 }} className="relative flex items-start gap-4"> {/* Timeline dot */} <div className={`relative z-10 flex items-center justify-center w-12 h-12 rounded-full border-2 ${ isPast ? getEventColor(event.type) : isUpcoming ? 'bg-gray-50 text-gray-700 border-gray-200' : isPending ? 'bg-gray-50 text-gray-700 border-gray-200' : 'bg-gray-50 text-gray-400 border-gray-200' }`}> {getEventIcon(event.type)} </div> {/* Content */} <div className="flex-1 min-w-0 pb-6"> <div className="flex items-start justify-between gap-4"> <div className="space-y-2"> <div className="flex items-center gap-3"> <h4 className={`font-medium ${ isPast ? 'text-foreground' : isUpcoming ? 'text-gray-800' : isPending ? 'text-gray-800' : 'text-muted-foreground' }`}> {event.title} </h4> {event.status && ( <Badge variant={isPast ? 'default' : isUpcoming ? 'secondary' : 'destructive'} className="text-xs"> {event.status === 'completed' && 'Completado'} {event.status === 'pending' && 'Pendiente'} {event.status === 'upcoming' && 'Próximo'} </Badge> )} </div> {event.description && ( <p className="text-sm text-muted-foreground"> {event.description} </p> )} <div className="flex items-center gap-3 text-xs text-muted-foreground"> <div className="flex items-center gap-2"> <Avatar className="h-6 w-6"> <AvatarImage src={event.actor.avatar} alt={event.actor.name} /> <AvatarFallback className="text-xs"> {event.actor.name.charAt(0)} </AvatarFallback> </Avatar> <span>{event.actor.name}</span> </div> <span>•</span> <span>{formatRelativeTime(event.timestamp)}</span> <span>•</span> <span>{formatDate(event.timestamp, 'time')}</span> </div> </div> {/* Alert for overdue items */} {isPending && event.type === 'milestone' && ( <div className="flex-shrink-0"> <div className="flex items-center gap-1 px-2 py-1 bg-gray-50 text-gray-700 text-xs rounded-full"> <AlertTriangle className="h-3 w-3"/> <span>Atrasado</span> </div> </div> )} </div> </div> </motion.div> ); })} </div> </div> {/* Statistics */} <div className="mt-8 p-4 bg-muted/50 rounded"> <h4 className="font-medium mb-3">Estadísticas del timeline</h4> <div className="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm"> <div className="text-center"> <div className="font-semibold text-lg text-gray-700"> {events.filter(e => e.status === 'completed').length} </div> <div className="text-muted-foreground">Completados</div> </div> <div className="text-center"> <div className="font-semibold text-lg text-gray-700"> {events.filter(e => e.status === 'upcoming').length} </div> <div className="text-muted-foreground">Próximos</div> </div> <div className="text-center"> <div className="font-semibold text-lg text-gray-700"> {events.filter(e => e.status === 'pending').length} </div> <div className="text-muted-foreground">Atrasados</div> </div> <div className="text-center"> <div className="font-semibold text-lg text-gray-700"> {Math.ceil((new Date(collaboration.timeline.deadline).getTime() - new Date().getTime()) / (1000 * 60 * 60 * 24))} </div> <div className="text-muted-foreground">Días restantes</div> </div> </div> </div> </div> </CardContent> </Card> );
}; export default CollaborationTimeline;